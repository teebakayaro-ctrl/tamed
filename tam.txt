--!strict
-- Wild Horse Scanner (Client) — StarterPlayerScripts → LocalScript

local Players                  = game:GetService("Players")
local CollectionService        = game:GetService("CollectionService")
local ProximityPromptService   = game:GetService("ProximityPromptService")
local RunService               = game:GetService("RunService")
local Workspace                = game:GetService("Workspace")

local LP = Players.LocalPlayer

-- ============== CONFIG ============
local CONFIG = {
    SCAN_RADIUS = 300,               -- studs
    SCAN_INTERVAL = 0.35,            -- seconds
    HORSE_TAGS = { "Horse", "WildHorse" },
    HORSE_NAME_CONTAINS = { "Horse", "Mustang", "Wild" },
    MAX_PARTS_FOR_COLOR = 30,        -- limit color sampling to be cheap
    REQUIRE_LINE_OF_SIGHT = false,   -- set true if you only want visible horses
    UI_MAX_ROWS = 10,
}

-- ============== UI SETUP =========
local function makeUI()
    local sg = Instance.new("ScreenGui")
    sg.Name = "WildHorseScanner"
    sg.ResetOnSpawn = false
    sg.IgnoreGuiInset = true
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local frame = Instance.new("Frame")
    frame.Name = "Panel"
    frame.AnchorPoint = Vector2.new(0, 0)
    frame.Position = UDim2.new(0, 10, 0, 40)
    frame.Size = UDim2.new(0, 360, 0, 260)
    frame.BackgroundTransparency = 0.25
    frame.BackgroundColor3 = Color3.fromRGB(18,18,18)
    frame.BorderSizePixel = 0
    frame.Parent = sg

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -10, 0, 22)
    title.Position = UDim2.new(0, 10, 0, 6)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextColor3 = Color3.fromRGB(235, 255, 235)
    title.TextSize = 16
    title.Text = "Wild Horse Scanner"
    title.Parent = frame

    local scrolling = Instance.new("ScrollingFrame")
    scrolling.Name = "List"
    scrolling.Position = UDim2.new(0, 10, 0, 32)
    scrolling.Size = UDim2.new(1, -20, 1, -42)
    scrolling.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrolling.ScrollBarThickness = 6
    scrolling.Active = true
    scrolling.BackgroundTransparency = 0.35
    scrolling.BackgroundColor3 = Color3.fromRGB(25,25,25)
    scrolling.BorderSizePixel = 0
    scrolling.Parent = frame

    local template = Instance.new("TextLabel")
    template.Name = "RowTemplate"
    template.Visible = false
    template.Size = UDim2.new(1, -8, 0, 22)
    template.BackgroundTransparency = 1
    template.Font = Enum.Font.Code
    template.TextXAlignment = Enum.TextXAlignment.Left
    template.TextColor3 = Color3.fromRGB(235,235,235)
    template.TextSize = 14
    template.Text = ""
    template.Parent = scrolling

    sg.Parent = LP:WaitForChild("PlayerGui")
    return scrolling, template, title
end

local List, RowTemplate, Title = makeUI()

-- ============== HELPERS ===========
local function getCharacter()
    local c = LP.Character or LP.CharacterAdded:Wait()
    return c
end

local function hrpOf(model: Model): BasePart?
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso") or model:FindFirstChildWhichIsA("BasePart")
end

local function instancePath(inst: Instance): string
    local parts = {}
    local cur: Instance? = inst
    while cur do
        table.insert(parts, 1, cur.Name)
        cur = cur.Parent
        if cur == game then break end
    end
    return table.concat(parts, ".")
end

local function isHorseModel(m: Instance): boolean
    if not m:IsA("Model") then return false end
    for _, t in ipairs(CONFIG.HORSE_TAGS) do
        if CollectionService:HasTag(m, t) then
            return true
        end
    end
    local lower = string.lower(m.Name)
    for _, frag in ipairs(CONFIG.HORSE_NAME_CONTAINS) do
        if string.find(lower, string.lower(frag)) then
            return true
        end
    end
    return false
end

local function nearbyCandidates(origin: Vector3): {Model}
    local out = {}
    for _, m in ipairs(Workspace:GetDescendants()) do
        if isHorseModel(m) then
            local root = hrpOf(m)
            if root then
                local d = (root.Position - origin).Magnitude
                if d <= CONFIG.SCAN_RADIUS then
                    table.insert(out, m)
                end
            end
        end
    end
    return out
end

local function averageColor(model: Model): Color3?
    local sumR, sumG, sumB, count = 0,0,0,0
    local n = 0
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then
            local c = d.Color
            sumR += c.R; sumG += c.G; sumB += c.B
            count += 1
            n += 1
            if n >= CONFIG.MAX_PARTS_FOR_COLOR then break end
        end
    end
    if count == 0 then return nil end
    return Color3.new(sumR / count, sumG / count, sumB / count)
end

local function lineOfSight(fromPos: Vector3, toPos: Vector3, ignore: Instance?): boolean
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = { ignore or Workspace.CurrentCamera }
    local result = Workspace:Raycast(fromPos, (toPos - fromPos), params)
    if not result then return true end
    -- If we hit very near the target point, consider LOS true
    return (result.Position - toPos).Magnitude < 2.0
end

local function findPromptOn(model: Instance)
    local best, bestName = nil, ""
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            best = d
            bestName = d.ActionText ~= "" and d.ActionText or d.ObjectText
            break
        end
    end
    return best, bestName
end

-- Keep simple velocity estimation per model
local lastPos: {[Instance]: Vector3} = {}
local lastTime: {[Instance]: number} = {}

local function estimateSpeed(model: Model): number
    local root = hrpOf(model)
    if not root then return 0 end
    local now = time()
    local prevP = lastPos[model]
    local prevT = lastTime[model]
    lastPos[model] = root.Position
    lastTime[model] = now
    if prevP and prevT then
        local dt = math.max(1e-3, now - prevT)
        return (root.Position - prevP).Magnitude / dt
    end
    return 0
end

local function formatColor3(c: Color3?): string
    if not c then return "n/a" end
    return string.format("rgb(%d,%d,%d)", math.floor(c.R*255), math.floor(c.G*255), math.floor(c.B*255))
end

-- Read common attributes safely
local function readAttr(inst: Instance, name: string): any
    local ok, v = pcall(function() return inst:GetAttribute(name) end)
    if ok then return v end
    return nil
end

-- ============== RENDER LIST =========
local rowPool: {TextLabel} = {}

local function getRow(i: number): TextLabel
    if not rowPool[i] then
        local r = RowTemplate:Clone()
        r.Visible = true
        r.Position = UDim2.new(0, 0, 0, (i-1)*24)
        r.Parent = List
        rowPool[i] = r
    end
    return rowPool[i]
end

local function hideRows(fromIndex: number)
    for i = fromIndex, #rowPool do
        if rowPool[i] then rowPool[i].Visible = false end
    end
end

-- ============== MAIN LOOP ===========
task.spawn(function()
    local char = getCharacter()
    local hrp = hrpOf(char) :: BasePart

    while true do
        task.wait(CONFIG.SCAN_INTERVAL)
        if not hrp or not hrp.Parent then
            char = getCharacter()
            hrp = hrpOf(char) :: BasePart
            if not hrp then continue end
        end

        local origin = hrp.Position
        local horses = nearbyCandidates(origin)

        -- Sort by distance
        table.sort(horses, function(a, b)
            local ra = hrpOf(a); local rb = hrpOf(b)
            if not ra or not rb then return false end
            return (ra.Position - origin).Magnitude < (rb.Position - origin).Magnitude
        end)

        local visibleCount = 0
        for idx, model in ipairs(horses) do
            if idx > CONFIG.UI_MAX_ROWS then break end

            local root = hrpOf(model)
            if not root then continue end
            local dist = (root.Position - origin).Magnitude

            -- line of sight
            local los = lineOfSight(origin + Vector3.new(0, 3, 0), root.Position + Vector3.new(0, 2, 0), char)
            if CONFIG.REQUIRE_LINE_OF_SIGHT and not los then
                -- skip from UI but keep tracking speed
                estimateSpeed(model)
                continue
            end

            -- estimate speed & color
            local speed = estimateSpeed(model)
            local avgColor = averageColor(model)

            -- attributes and prompt
            local prompt, promptLabel = findPromptOn(model)
            local keyStr = prompt and tostring(prompt.KeyboardKeyCode):gsub("Enum%.KeyCode%.","") or "n/a"

            local health = readAttr(model, "Health") or readAttr(model, "HP")
            local maxHealth = readAttr(model, "MaxHealth") or readAttr(model, "MaxHP")
            local tamed = readAttr(model, "Tamed")
            local owner = readAttr(model, "Owner") or readAttr(model, "OwnerName")

            local row = getRow(idx)
            row.Visible = true
            row.Text = string.format(
                "[%02d] d=%.1f | v=%.1f | LOS=%s | name=%s | color=%s | prompt=%s[%s]%s%s",
                idx,
                dist,
                speed,
                los and "yes" or "no",
                model.Name,
                formatColor3(avgColor),
                promptLabel ~= "" and promptLabel or "n/a",
                keyStr,
                health and (" | HP="..tostring(health)..(maxHealth and ("/"..tostring(maxHealth)) or "")) or "",
                tamed ~= nil and (" | Tamed="..tostring(tamed)) or (owner and (" | Owner="..tostring(owner)) or "")
            )

            -- Also print a more verbose line (once every couple seconds) if close
            if dist < 40 then
                print(("[WildHorse] %s | path=%s | d=%.1f | v=%.1f | color=%s | prompt=%s[%s] | HP=%s/%s | Tamed=%s | Owner=%s"):format(
                    model.Name,
                    instancePath(model),
                    dist,
                    speed,
                    formatColor3(avgColor),
                    promptLabel ~= "" and promptLabel or "n/a",
                    keyStr,
                    tostring(health or "n/a"),
                    tostring(maxHealth or "n/a"),
                    tostring(tamed or "n/a"),
                    tostring(owner or "n/a")
                ))
            end

            visibleCount += 1
        end

        Title.Text = ("Wild Horse Scanner — %d within %dstuds"):format(#horses, CONFIG.SCAN_RADIUS)
        List.CanvasSize = UDim2.new(0, 0, 0, math.max(0, visibleCount * 24))
        hideRows(visibleCount + 1)
    end
end)

-- ========== OPTIONAL: quick copy of nearest horse info ==========
-- Press O to copy the nearest horse’s summary to the Output (easy to share/debug).
local UIS = game:GetService("UserInputService")
UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.O then
        local char = LP.Character
        local hrp = char and hrpOf(char)
        if not hrp then return end
        local origin = hrp.Position
        local horses = nearbyCandidates(origin)
        local nearest, nd, nr = nil, math.huge, nil
        for _, m in ipairs(horses) do
            local r = hrpOf(m)
            if r then
                local d = (r.Position - origin).Magnitude
                if d < nd then nd, nearest, nr = d, m, r end
            end
        end
        if nearest and nr then
            local speed = estimateSpeed(nearest)
            local c = averageColor(nearest)
            local prompt, label = findPromptOn(nearest)
            local keyStr = prompt and tostring(prompt.KeyboardKeyCode):gsub("Enum%.KeyCode%.","") or "n/a"
            print(("-- Nearest Horse --\nName=%s\nPath=%s\nDist=%.1f\nSpeed=%.1f\nColor=%s\nPrompt=%s[%s]")
                :format(nearest.Name, instancePath(nearest), nd, speed, formatColor3(c), label ~= "" and label or "n/a", keyStr))
        else
            print("-- Nearest Horse -- none in range")
        end
    end
end)
