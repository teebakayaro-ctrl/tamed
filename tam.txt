--!strict
-- Combined Panel: Tame Mode (top) + Lasso Market (bottom)
-- J toggles panel/icon. Quantities of 0 are skipped on purchase.

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local CollectionService = game:GetService("CollectionService")

local LP = Players.LocalPlayer

-- ===================== Shared helpers =====================
local function char() return LP.Character or LP.CharacterAdded:Wait() end
local function rootOf(m: Model): BasePart?
	return m:FindFirstChild("HumanoidRootPart")
		or m:FindFirstChild("Torso")
		or m:FindFirstChildWhichIsA("BasePart")
end
local function myRoot(): BasePart?
	return rootOf(char())
end
local function getAttr(inst: Instance, k: string)
	local ok, v = pcall(function() return inst:GetAttribute(k) end)
	return ok and v or nil
end

-- Horse detection
local HORSE_NAME_FRAGS = {
	"Horse","Unicorn","Gargoyle","Equus","Bisorse","Pony","Caprine","Kelpie","Peryton",
	"Fae","Plush","Flora","Cybred","Celestial","Saurequine","Hippocampus","Kirin",
	"Cactaline","Clydesdale","Felorse","Akhal","Teke"
}
local HORSE_TAGS = { "Horse","WildHorse","Mount","Tameable" }
local SPECIES_ATTR = "Species"

local function looksHorseyName(s: string): boolean
	local low = string.lower(s)
	for _, frag in ipairs(HORSE_NAME_FRAGS) do
		if low:find(string.lower(frag), 1, true) then return true end
	end
	return false
end
local function isPlayerCharacter(m: Instance): boolean
	if not m:IsA("Model") then return false end
	if Players:GetPlayerFromCharacter(m) then return true end
	if m.Parent and m.Parent.Name == "Characters" then
		for _, p in ipairs(Players:GetPlayers()) do
			if p.Name == m.Name then return true end
		end
	end
	return false
end
local function hasAnyTag(inst: Instance, tags: {string})
	for _, t in ipairs(tags) do if CollectionService:HasTag(inst, t) then return true end end
	return false
end
local function isHorseLike(m: Instance): boolean
	if not m:IsA("Model") then return false end
	if isPlayerCharacter(m) then return false end
	if not rootOf(m) then return false end
	if hasAnyTag(m, HORSE_TAGS) then return true end
	local spec = getAttr(m, SPECIES_ATTR)
	if type(spec) == "string" and looksHorseyName(spec) then return true end
	if looksHorseyName(m.Name) then return true end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
			if t:find("tame") or t:find("mount") or t:find("ride") then return true end
		end
	end
	return false
end
local function speciesOf(m: Model): string
	local s = getAttr(m, SPECIES_ATTR)
	if type(s) == "string" and #s > 0 then return s end
	for _, frag in ipairs(HORSE_NAME_FRAGS) do
		if string.lower(m.Name):find(string.lower(frag), 1, true) then return frag end
	end
	return "Unknown"
end
local function nearestHorse(from: Vector3): (Model?, BasePart?, number)
	local bestM, bestR, bestD = nil, nil, math.huge
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Model") and isHorseLike(inst) then
			local r = rootOf(inst)
			if r then
				local d = (r.Position - from).Magnitude
				if d < bestD then bestD, bestM, bestR = d, inst, r end
			end
		end
	end
	return bestM, bestR, bestD
end
local function findTamePrompt(m: Model): ProximityPrompt?
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
			if t:find("tame") or t:find("mount") or t:find("ride") then return d end
		end
	end
	return nil
end
local successVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
local function tapKey(key: Enum.KeyCode)
	if successVIM and VIM then
		VIM:SendKeyEvent(true, key, false, game); task.wait(0.05)
		VIM:SendKeyEvent(false, key, false, game)
	end
end

-- Optional remotes (only used if present)
local TeleportRemote: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local t = rem and rem:FindFirstChild("TeleportRemote")
	return (t and t:IsA("RemoteFunction")) and t or nil
end)()
local GetTamingHorses: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local g = rem and rem:FindFirstChild("GetTamingHorses")
	return (g and g:IsA("RemoteFunction")) and g or nil
end)()

-- ===================== UI: Combined Panel =====================
local gui = Instance.new("ScreenGui")
gui.Name = "HorseMarketAndTame"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
gui.Parent = LP:WaitForChild("PlayerGui")

local panel = Instance.new("Frame")
panel.Name = "Panel"
panel.Position = UDim2.new(0, 24, 0, 80)
panel.Size = UDim2.new(0, 420, 0, 300) -- taller to fit tame section + market
panel.BackgroundColor3 = Color3.fromRGB(22,22,22)
panel.BackgroundTransparency = 0.1
panel.BorderSizePixel = 0
panel.Active = true
panel.Parent = gui

-- drag
do
	local dragging, dragStart, startPos = false, nil, nil
	panel.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true; dragStart = input.Position; startPos = panel.Position
		end
	end)
	panel.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
	end)
	UIS.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement and dragStart and startPos then
			local delta = input.Position - dragStart
			panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

-- Minimize → icon
local icon = Instance.new("TextButton")
icon.Name = "MiniIcon"
icon.Size = UDim2.new(0, 40, 0, 40)
icon.Position = panel.Position
icon.Text = "🪢"
icon.Font = Enum.Font.SourceSansBold
icon.TextSize = 24
icon.BackgroundColor3 = Color3.fromRGB(35,35,35)
icon.BorderSizePixel = 0
icon.Visible = false
icon.Parent = gui
local function minimize() icon.Position = panel.Position; panel.Visible=false; icon.Visible=true end
local function restore() panel.Visible=true; icon.Visible=false end
icon.MouseButton1Click:Connect(restore)
UIS.InputBegan:Connect(function(i,g) if not g and i.KeyCode==Enum.KeyCode.J then if panel.Visible then minimize() else restore() end end end)

local minBtn = Instance.new("TextButton")
minBtn.Size = UDim2.new(0, 24, 0, 24)
minBtn.Position = UDim2.new(1, -28, 0, 4)
minBtn.Text = "–"
minBtn.TextScaled = true
minBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
minBtn.BorderSizePixel = 0
minBtn.Parent = panel
minBtn.MouseButton1Click:Connect(minimize)

-- ========= Tame section (TOP) =========
local tameHeader = Instance.new("TextLabel")
tameHeader.BackgroundTransparency = 1
tameHeader.Position = UDim2.new(0, 10, 0, 6)
tameHeader.Size = UDim2.new(1, -40, 0, 20)
tameHeader.Font = Enum.Font.Code
tameHeader.TextSize = 16
tameHeader.TextXAlignment = Enum.TextXAlignment.Left
tameHeader.TextColor3 = Color3.fromRGB(220,255,220)
tameHeader.Text = "Tame Mode"
tameHeader.Parent = panel

local tameToggle = Instance.new("TextButton")
tameToggle.Position = UDim2.new(0, 10, 0, 30)
tameToggle.Size = UDim2.new(0, 110, 0, 24)
tameToggle.Text = "OFF"
tameToggle.Font = Enum.Font.Code
tameToggle.TextSize = 14
tameToggle.BackgroundColor3 = Color3.fromRGB(90,40,40)
tameToggle.BorderSizePixel = 0
tameToggle.TextColor3 = Color3.fromRGB(240,240,240)
tameToggle.Parent = panel

local tameTarget = Instance.new("TextLabel")
tameTarget.BackgroundTransparency = 1
tameTarget.Position = UDim2.new(0, 130, 0, 30)
tameTarget.Size = UDim2.new(1, -140, 0, 24)
tameTarget.Font = Enum.Font.Code
tameTarget.TextSize = 14
tameTarget.TextXAlignment = Enum.TextXAlignment.Left
tameTarget.TextColor3 = Color3.fromRGB(235,235,235)
tameTarget.Text = "Target: n/a"
tameTarget.Parent = panel

local tameStatus = Instance.new("TextLabel")
tameStatus.BackgroundTransparency = 1
tameStatus.Position = UDim2.new(0, 10, 0, 56)
tameStatus.Size = UDim2.new(1, -20, 0, 20)
tameStatus.Font = Enum.Font.Code
tameStatus.TextSize = 13
tameStatus.TextXAlignment = Enum.TextXAlignment.Left
tameStatus.TextColor3 = Color3.fromRGB(200,200,200)
tameStatus.Text = "Ready."
tameStatus.Parent = panel

-- ========= Horse Info Overlay (toggle) =========
local OVERLAY_ON = false

local overlays: {[Model]: BillboardGui} = {}

local function makeBillboard(): BillboardGui
	local bb = Instance.new("BillboardGui")
	bb.Name = "HorseMiniBB"
	bb.AlwaysOnTop = true
	bb.Size = UDim2.fromOffset(260, 20)
	bb.StudsOffset = Vector3.new(0, 4, 0)
	bb.MaxDistance = 500
	bb.LightInfluence = 0
	local txt = Instance.new("TextLabel")
	txt.Name = "Text"
	txt.BackgroundTransparency = 1
	txt.Size = UDim2.fromScale(1, 1)
	txt.TextXAlignment = Enum.TextXAlignment.Center
	txt.Font = Enum.Font.Code
	txt.TextSize = 16
	txt.TextColor3 = Color3.fromRGB(235,255,235)
	txt.Text = ""
	txt.Parent = bb
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.new(0,0,0)
	stroke.Thickness = 1
	stroke.Parent = txt
	return bb
end

local function ensureOverlay(m: Model): BillboardGui
	local bb = overlays[m]
	if bb and bb.Parent then return bb end
	local root = rootOf(m); if not root then error("no root") end
	bb = makeBillboard()
	bb.Adornee = root
	bb.Parent = m
	overlays[m] = bb
	return bb
end

local function forgetOverlay(m: Model)
	local bb = overlays[m]
	if bb then bb:Destroy(); overlays[m] = nil end
end

local overlayToggle = Instance.new("TextButton")
overlayToggle.Position = UDim2.new(0, 10, 0, 78)
overlayToggle.Size = UDim2.new(0, 200, 0, 22)
overlayToggle.Text = "Overlay: OFF (H)"
overlayToggle.Font = Enum.Font.Code
overlayToggle.TextSize = 14
overlayToggle.BackgroundColor3 = Color3.fromRGB(90,40,40)
overlayToggle.BorderSizePixel = 0
overlayToggle.TextColor3 = Color3.fromRGB(240,240,240)
overlayToggle.Parent = panel

local function setOverlay(v: boolean)
	OVERLAY_ON = v
	overlayToggle.Text = v and "Overlay: ON (H)" or "Overlay: OFF (H)"
	overlayToggle.BackgroundColor3 = v and Color3.fromRGB(40,90,40) or Color3.fromRGB(90,40,40)
	for _, bb in pairs(overlays) do bb.Enabled = OVERLAY_ON end
end
overlayToggle.MouseButton1Click:Connect(function() setOverlay(not OVERLAY_ON) end)

UIS.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.H then
		setOverlay(not OVERLAY_ON)
	end
end)

task.spawn(function()
	while true do
		task.wait(0.30)
		local my = myRoot()
		if not my then continue end
		local origin = my.Position
		local seen: {[Model]: boolean} = {}
		for _, inst in ipairs(workspace:GetDescendants()) do
			if inst:IsA("Model") and isHorseLike(inst) then
				local r = rootOf(inst)
				if r then
					local dist = (r.Position - origin).Magnitude
					local bb = ensureOverlay(inst)
					bb.Enabled = OVERLAY_ON
					local label = (bb:FindFirstChild("Text") :: TextLabel)
					label.Text = string.format("%s — %.1f", speciesOf(inst), dist)
					seen[inst] = true
				end
			end
		end
		for m in pairs(overlays) do
			if not m.Parent or not seen[m] then
				forgetOverlay(m)
			end
		end
	end
end)

-- ========= Market section (BOTTOM) =========
-- Hardcoded catalog per your choice
type LassoItem = { id: string, name: string, price: number }
local Catalog: {LassoItem} = {
	{ id = "TornLasso",    name = "TornLasso",    price = 50 },
	{ id = "WesternLasso", name = "WesternLasso", price = 90 },
}
local Order: { [string]: number } = {}; for _,it in ipairs(Catalog) do Order[it.id]=0 end

local marketHeader = Instance.new("TextLabel")
marketHeader.BackgroundTransparency = 1
marketHeader.Position = UDim2.new(0, 10, 0, 108) -- under tame + overlay
marketHeader.Size = UDim2.new(1, -20, 0, 20)
marketHeader.Font = Enum.Font.Code
marketHeader.TextSize = 16
marketHeader.TextXAlignment = Enum.TextXAlignment.Left
marketHeader.TextColor3 = Color3.fromRGB(220,255,220)
marketHeader.Text = "Lasso Market"
marketHeader.Parent = panel

local list = Instance.new("Frame")
list.BackgroundTransparency = 1
list.Position = UDim2.new(0, 10, 0, 110)
list.Size = UDim2.new(1, -20, 0, 130)
list.Parent = panel

local function mkRow(it: LassoItem, y: number)
	local r = Instance.new("Frame"); r.BackgroundTransparency = 1
	r.Size = UDim2.new(1, 0, 0, 28); r.Position = UDim2.new(0, 0, 0, y); r.Parent = list

	local nameL = Instance.new("TextLabel")
	nameL.BackgroundTransparency = 1; nameL.Position = UDim2.new(0,0,0,4)
	nameL.Size = UDim2.new(0.5,0,1,-8); nameL.Font = Enum.Font.Code; nameL.TextSize = 14
	nameL.TextXAlignment = Enum.TextXAlignment.Left; nameL.TextColor3 = Color3.fromRGB(235,235,235)
	nameL.Text = it.name; nameL.Parent = r

	local priceL = nameL:Clone()
	priceL.Position = UDim2.new(0.5,0,0,4); priceL.Size = UDim2.new(0.15,0,1,-8)
	priceL.TextColor3 = Color3.fromRGB(200,220,255); priceL.Text = tostring(it.price); priceL.Parent = r

	local minus = Instance.new("TextButton")
	minus.Position = UDim2.new(0.68,0,0,2); minus.Size = UDim2.new(0,24,0,24)
	minus.Text = "–"; minus.BackgroundColor3 = Color3.fromRGB(50,50,50); minus.BorderSizePixel = 0; minus.Parent = r

	local qty = Instance.new("TextBox")
	qty.Position = UDim2.new(0.78,0,0,2); qty.Size = UDim2.new(0,40,0,24)
	qty.Text = tostring(Order[it.id]); qty.ClearTextOnFocus = false
	qty.BackgroundColor3 = Color3.fromRGB(30,30,30); qty.TextColor3 = Color3.fromRGB(240,240,240)
	qty.BorderSizePixel = 0; qty.Font = Enum.Font.Code; qty.TextSize = 14; qty.Parent = r

	local plus = minus:Clone(); plus.Text = "+"; plus.Position = UDim2.new(0.78,44,0,2); plus.Parent = r

	local function clamp(n:number) return math.max(0, math.min(999, math.floor((tonumber(n) or 0)+0.0001))) end
	local function setQty(n:number) n=clamp(n); Order[it.id]=n; qty.Text=tostring(n); end
	minus.MouseButton1Click:Connect(function() setQty((Order[it.id] or 0)-1) end)
	plus.MouseButton1Click:Connect(function() setQty((Order[it.id] or 0)+1) end)
	qty.FocusLost:Connect(function() setQty(qty.Text) end)
end
for i,it in ipairs(Catalog) do mkRow(it, (i-1)*30) end

local totalL = Instance.new("TextLabel")
totalL.BackgroundTransparency = 1
totalL.Position = UDim2.new(0, 10, 1, -52)
totalL.Size = UDim2.new(0.6, 0, 0, 20)
totalL.Font = Enum.Font.Code; totalL.TextSize = 14
totalL.TextXAlignment = Enum.TextXAlignment.Left
totalL.TextColor3 = Color3.fromRGB(235,255,235)
totalL.Text = "Queued total: 0"
totalL.Parent = panel

local buyBtn = Instance.new("TextButton")
buyBtn.Position = UDim2.new(1, -110, 1, -56)
buyBtn.Size = UDim2.new(0, 100, 0, 26)
buyBtn.Text = "Buy Now"
buyBtn.Font = Enum.Font.Code; buyBtn.TextSize = 14
buyBtn.BackgroundColor3 = Color3.fromRGB(40,80,40)
buyBtn.TextColor3 = Color3.fromRGB(240,240,240)
buyBtn.BorderSizePixel = 0
buyBtn.Parent = panel

local statusL = Instance.new("TextLabel")
statusL.BackgroundTransparency = 1
statusL.Position = UDim2.new(0, 10, 1, -26)
statusL.Size = UDim2.new(1, -20, 0, 20)
statusL.Font = Enum.Font.Code; statusL.TextSize = 13
statusL.TextXAlignment = Enum.TextXAlignment.Left
statusL.TextColor3 = Color3.fromRGB(200,200,200)
statusL.Text = "Ready."
statusL.Parent = panel

-- Update queued total
local function refreshTotal()
	local t=0; for _,it in ipairs(Catalog) do t += it.price*(Order[it.id] or 0) end
	totalL.Text = "Queued total: "..tostring(t)
end
task.spawn(function() while task.wait(0.4) do refreshTotal() end end)

-- ===================== Purchase Engine =====================
local PurchaseItemRemote: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local r = rem and rem:FindFirstChild("PurchaseItemRemote")
	return (r and r:IsA("RemoteFunction")) and r or nil
end)()

local function setStatus(msg: string) statusL.Text = msg; print("[Market]", msg) end
local function callPurchase(itemId: string, qty: number): boolean
	if qty <= 0 then return true end
	if not PurchaseItemRemote then setStatus("PurchaseItemRemote not found."); return false end

	local variants = {
		function() return itemId, qty end,
		function() return { itemId=itemId, quantity=qty } end,
		function() return { Id=itemId, Qty=qty } end,
		function() return itemId end,
	}
	for _, build in ipairs(variants) do
		local a, b = build()
		local ok = pcall(function()
			return (PurchaseItemRemote :: RemoteFunction):InvokeServer(a,b)
		end)
		if ok then return true end
	end
	return false
end
local function buyQueued()
	local any=false; for _,it in ipairs(Catalog) do if (Order[it.id] or 0) > 0 then any=true break end end
	if not any then setStatus("Nothing to buy (all quantities are 0)."); return end
	for _, it in ipairs(Catalog) do
		local q = Order[it.id] or 0
		if q > 0 then
			setStatus(("Buying %s x%d..."):format(it.name, q))
			local ok = callPurchase(it.id, q)
			setStatus(ok and ("OK: "..it.name.." x"..q) or ("Failed: "..it.name))
		end
	end
end
buyBtn.MouseButton1Click:Connect(buyQueued)
_G.TriggerLassoPurchase = function() buyQueued() end

-- force character to sit on the horse's seat
_G.ForceSitOnHorse = function(horse: Instance)
    local hum = (LP.Character or LP.CharacterAdded:Wait()):WaitForChild("Humanoid")
    local seat = horse:FindFirstChildWhichIsA("Seat", true)
    if not seat then
        warn("No seat found in horse:", horse)
        return false
    end

    -- teleport onto seat so Sit() works
    local root = hum.Parent:FindFirstChild("HumanoidRootPart")
    if root then
        root.CFrame = seat.CFrame + Vector3.new(0, 2, 0)
    end

    -- tell seat to accept us
    seat:Sit(hum)

    -- wait until conditions are live
    for i = 1, 20 do
        task.wait(0.05)
        if hum.Sit and hum.SeatPart == seat and hum:GetState() == Enum.HumanoidStateType.Seated then
            print("[Ride] Mounted successfully on", seat:GetFullName())
            return true
        end
    end
    return false
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

local function Char() return LP.Character or LP.CharacterAdded:Wait() end
local function Hum() return Char():WaitForChild("Humanoid") end
local function Root() return Char():WaitForChild("HumanoidRootPart") end

-- ================== FOLLOW UNDER TARGET ==================
local followConn: RBXScriptConnection? = nil
local _followTarget: BasePart? = nil
local _followOffsetY = -6

_G.StartFollowUnder = function(targetRoot: BasePart, yOffset: number?)
	if followConn then followConn:Disconnect(); followConn = nil end
	_followTarget = targetRoot
	_followOffsetY = yOffset or -6

	-- make character immune to bumps while following
	for _, p in ipairs(Char():GetDescendants()) do
		if p:IsA("BasePart") then p.CanCollide = false end
	end

	local hrp = Root()
	hrp.Anchored = true

	followConn = RunService.Heartbeat:Connect(function()
		if not _followTarget or not _followTarget.Parent then
			if followConn then followConn:Disconnect(); followConn = nil end
			hrp.Anchored = false
			for _, p in ipairs(Char():GetDescendants()) do
				if p:IsA("BasePart") then p.CanCollide = true end
			end
			return
		end
		local pos = _followTarget.Position + Vector3.new(0, _followOffsetY, 0)
		hrp.CFrame = CFrame.new(pos, _followTarget.Position + Vector3.new(0, 2, 0))
	end)
end

_G.StopFollow = function()
	if followConn then followConn:Disconnect(); followConn = nil end
	local hrp = Root()
	hrp.Anchored = false
	for _, p in ipairs(Char():GetDescendants()) do
		if p:IsA("BasePart") then p.CanCollide = true end
	end
	_followTarget = nil
end
-- =========================================================

-- ================== SEAT SPOOF (client) ==================
-- Creates a local Seat under the character, invisible & non-collide,
-- follows HRP tightly so Humanoid stays Seated with a SeatPart.
local _ghostSeat: Seat? = nil
local _seatConn: RBXScriptConnection? = nil

local function createGhostSeat()
	if _ghostSeat then return _ghostSeat end
	local seat = Instance.new("Seat")
	seat.Name = "GhostSeat_Local"
	seat.Anchored = true
	seat.Transparency = 1
	seat.CanCollide = false
	seat.Size = Vector3.new(2, 0.6, 2)
	seat.TopSurface = Enum.SurfaceType.Smooth
	seat.BottomSurface = Enum.SurfaceType.Smooth
	seat.Parent = workspace -- local-only since created by client
	_ghostSeat = seat
	return seat
end

_G.SeatSpoof_Start = function()
	local hum = Hum()
	local hrp = Root()
	local seat = createGhostSeat()

	-- keep the seat glued to our HRP (a tiny offset so Sit() works)
	if _seatConn then _seatConn:Disconnect(); _seatConn = nil end
	_seatConn = RunService.Heartbeat:Connect(function()
		if not _ghostSeat then return end
		_ghostSeat.CFrame = hrp.CFrame * CFrame.new(0, -1.5, 0)
	end)

	-- zero velocity and sit
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero
	seat:Sit(hum)

	-- wait until the trio matches: Seated/Sit/SeatPart
	for i=1,30 do
		RunService.Heartbeat:Wait()
		if hum.Sit and hum.SeatPart == seat and hum:GetState() == Enum.HumanoidStateType.Seated then
			return true
		end
	end
	return hum.Sit and hum.SeatPart ~= nil
end

_G.SeatSpoof_Stop = function()
	if _seatConn then _seatConn:Disconnect(); _seatConn = nil end
	local hum = Hum()
	if hum and hum.Sit then hum.Sit = false end
	if _ghostSeat then _ghostSeat:Destroy(); _ghostSeat = nil end
end

-- Convenience: ensure the exact “ride snapshot” before taming
_G.EnsureRideSnapshot = function()
	local hum = Hum()
	if hum.Sit and hum.SeatPart and hum:GetState() == Enum.HumanoidStateType.Seated then
		return true
	end
	return _G.SeatSpoof_Start()
end
-- =========================================================
-- ---- Target click helpers ----
local RS = game:GetService("ReplicatedStorage")

-- Find a good clickable BasePart on the horse
local function getTargetPart(horse: Instance): BasePart?
	if not horse then return nil end
	-- prefer HRP / Seat / saddle-like parts
	local hrp = horse:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then return hrp end
	local seat = horse:FindFirstChildWhichIsA("Seat", true)
	if seat then return seat end
	-- otherwise any part near the center
	local best, bestDist = nil, math.huge
	for _, d in ipairs(horse:GetDescendants()) do
		if d:IsA("BasePart") then
			local c = d.Position.Magnitude
			if c < bestDist then best, bestDist = d, c end
		end
	end
	return best
end

local KNOWN_TAME_REMOTE_NAMES = {
	"TameHorse","Tame","RightClickHorse","ClickHorse","UseLasso","LassoTame",
	"MountOrTame","InteractHorse","Interact"
}

local function findTameRemote()
	-- search a few common folders
	local buckets = { RS, RS:FindFirstChild("Remotes"), RS:FindFirstChild("RemoteEvents"), RS:FindFirstChild("RemoteFunctions") }
	for _, folder in ipairs(buckets) do
		if folder then
			for _, d in ipairs(folder:GetDescendants()) do
				if (d:IsA("RemoteEvent") or d:IsA("RemoteFunction")) then
					local n = d.Name:lower()
					for _, k in ipairs(KNOWN_TAME_REMOTE_NAMES) do
						if n:find(k:lower()) then return d end
					end
				end
			end
		end
	end
	return nil
end

-- Preferred click path:
-- 1) ClickDetector on any useful part
-- 2) ProximityPrompt on horse
-- 3) Known RemoteEvent/Function with horse as arg
-- 4) Fallback to world click (your old method)
local function clickOnTarget(horse: Model): boolean
	if not (horse and horse.Parent) then return false end
	local part = getTargetPart(horse); if not part then return false end

	-- (1) ClickDetector
	local function findCD(inst: Instance): ClickDetector?
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("ClickDetector") then return d end
		end
		return nil
	end
	local cd = findCD(horse) or findCD(part)
	if cd then
		pcall(fireclickdetector, cd)
		return true
	end

	-- (2) ProximityPrompt
	for _, d in ipairs(horse:GetDescendants()) do
		if d:IsA("ProximityPrompt") and d.Enabled then
			pcall(fireproximityprompt, d)
			return true
		end
	end

	-- (3) Remote
	local r = findTameRemote()
	if r then
		if r:IsA("RemoteEvent") then
			local ok = pcall(function() r:FireServer(horse) end)
			if ok then return true end
		else
			local ok = pcall(function() r:InvokeServer(horse) end)
			if ok then return true end
		end
	end

	-- (4) Fallback world click at the part
	if rightClickWorldPos then
		rightClickWorldPos(part.Position)
		return true
	end
	return false
end
-- ---- /helpers ----

-- ===================== Tame Logic =====================

-- inventory helpers (equip a lasso if we have one; otherwise buy one, then equip)
local Backpack = LP:WaitForChild("Backpack")
local function findToolByNames(names: {string}): Tool?
	for _, tool in ipairs(Backpack:GetChildren()) do
		if tool:IsA("Tool") then
			for _, n in ipairs(names) do
				if string.lower(tool.Name) == string.lower(n) then
					return tool
				end
			end
		end
	end
	-- also check currently equipped tool on character
	local charModel = char()
	for _, t in ipairs(charModel:GetChildren()) do
		if t:IsA("Tool") then
			for _, n in ipairs(names) do
				if string.lower(t.Name) == string.lower(n) then
					return t
				end
			end
		end
	end
	return nil
end

local function equipTool(tool: Tool?)
	if not tool then return false end
	local ch = char()
	local hum = ch:FindFirstChildOfClass("Humanoid")
	if not hum then return false end
	local ok = pcall(function() hum:EquipTool(tool) end)
	return ok
end

-- Build preferred lasso order:
-- 1) any catalog item you already own (in the order user set in the market UI: non-0 first)
-- 2) otherwise, first catalog item
local function preferredLassoName(): string?
	local nonZero: {string} = {}
	for _, it in ipairs(Catalog) do
		if (Order[it.id] or 0) > 0 then table.insert(nonZero, it.name) end
	end
	if #nonZero > 0 then return nonZero[1] end
	return (Catalog[1] and Catalog[1].name) or nil
end

local function ensureLassoEquipped(): boolean
	local names = {}
	-- prefer items user selected in the market first
	for _, it in ipairs(Catalog) do
		if (Order[it.id] or 0) > 0 then table.insert(names, it.name) end
	end
	-- then try all catalog names
	for _, it in ipairs(Catalog) do table.insert(names, it.name) end

	local have = findToolByNames(names)
	if have then return equipTool(have) end

	-- no lasso found → attempt to buy the first catalog lasso then equip on arrival
	local first = Catalog[1]
	if first then
		Order[first.id] = math.max(1, Order[first.id] or 0)
		if _G.TriggerLassoPurchase then _G.TriggerLassoPurchase() end
		-- wait briefly for inventory to update
		for _ = 1, 40 do
			task.wait(0.1)
			local got = findToolByNames({ first.name })
			if got then return equipTool(got) end
		end
	end
	return false
end

-- right-click helper
local successVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
local function rightClickWorldPos(worldPos: Vector3)
	if not (successVIM and VIM) then return end
	local cam = workspace.CurrentCamera
	if not cam then return end
	local viewportPos, onScreen = cam:WorldToViewportPoint(worldPos)
	if not onScreen then
		-- still move the mouse near the center as a fallback
		viewportPos = Vector3.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2, 0)
	end
	-- Move cursor and send RIGHT mouse down/up
	VIM:SendMouseMoveEvent(viewportPos.X, viewportPos.Y, game)
	task.wait(0.02)
	VIM:SendMouseButtonEvent(viewportPos.X, viewportPos.Y, 1, true, game, 0)  -- 1 = Right
	task.wait(0.04)
	VIM:SendMouseButtonEvent(viewportPos.X, viewportPos.Y, 1, false, game, 0)
end

-- tame session state + log
local TAME_ACTIVE = false
local TARGET: Model? = nil
local TARGET_ROOT: BasePart? = nil
local LAST_CLICK_T = 0
_G.TameLog = _G.TameLog or {}

local function logTameEvent(kind: string, extra: table?)
	local entry = {
		time = os.time(),
		kind = kind,
		target = TARGET and TARGET:GetFullName() or "nil",
		species = TARGET and speciesOf(TARGET) or "Unknown",
		pos = TARGET_ROOT and TARGET_ROOT.Position,
		extra = extra or {},
	}
	table.insert(_G.TameLog, entry)
	print("[TameLog]", kind, entry.species, entry.target)
end

local function setTameActive(v: boolean)
	TAME_ACTIVE = v
	tameToggle.Text = v and "ON" or "OFF"
	tameToggle.BackgroundColor3 = v and Color3.fromRGB(40,90,40) or Color3.fromRGB(90,40,40)
	tameStatus.Text = v and "Seeking nearest horse…" or "Paused."
	if not v then
		TARGET, TARGET_ROOT = nil, nil
		tameTarget.Text = "Target: n/a"
		local hrp = myRoot()
		if hrp then hrp.Anchored = false end
	end
end
tameToggle.MouseButton1Click:Connect(function() setTameActive(not TAME_ACTIVE) end)

-- main loop
task.spawn(function()

	while true do
		task.wait(0.25)
		local hrp = myRoot(); if not hrp then continue end
		if not TAME_ACTIVE then continue end

		-- 2) ensure lasso equipped (non-0 first; else first catalog)
		local okEquip = ensureLassoEquipped()
		if not okEquip then
			tameStatus.Text = "No lasso yet—trying to purchase/equip…"
		end

		-- acquire target if needed
		if (not TARGET) or (not TARGET.Parent) then
			local t, tR = nearestHorse(hrp.Position)
			TARGET, TARGET_ROOT = t, tR
			if TARGET and TARGET_ROOT then
				tameTarget.Text = string.format("Target: %s (%.1f)", speciesOf(TARGET), (TARGET_ROOT.Position - hrp.Position).Magnitude)
				tameStatus.Text = "Target acquired."
				logTameEvent("target_acquired")
			else
				tameTarget.Text = "Target: n/a"; tameStatus.Text = "No horse found."
			end
		end

		-- 3) teleport directly under target and anchor self
		if TARGET and TARGET_ROOT then
			-- When you lock on a target:
            _G.StartFollowUnder(TARGET_ROOT, -15)          -- 1) fly-follow under the horse
            local ok = _G.EnsureRideSnapshot()            -- 2) force Seated/Sit/SeatPart trio (like your screenshot)
            if not ok then
                tameStatus.Text = "Ride snapshot not ready — retrying…"
            else

                -- Try to tame by clicking directly on the target:
                local clicked = clickOnTarget(TARGET)
                if clicked then
                    tameStatus.Text = "Clicked target (CD/Prompt/Remote/fallback)"
                else
                    tameStatus.Text = "No clickable path found; retrying…"
                end

            end
			
		end
	end
end)
