--!strict
-- Combined Panel: Tame Mode (top) + Lasso Market (bottom)
-- J toggles panel/icon. Quantities of 0 are skipped on purchase.

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local CollectionService = game:GetService("CollectionService")

local LP = Players.LocalPlayer

-- ===================== Shared helpers =====================
local function char() return LP.Character or LP.CharacterAdded:Wait() end
local function rootOf(m: Model): BasePart?
	return m:FindFirstChild("HumanoidRootPart")
		or m:FindFirstChild("Torso")
		or m:FindFirstChildWhichIsA("BasePart")
end
local function myRoot(): BasePart?
	return rootOf(char())
end
local function getAttr(inst: Instance, k: string)
	local ok, v = pcall(function() return inst:GetAttribute(k) end)
	return ok and v or nil
end

-- Horse detection
local HORSE_NAME_FRAGS = {
	"Horse","Unicorn","Gargoyle","Equus","Bisorse","Pony","Caprine","Kelpie","Peryton",
	"Fae","Plush","Flora","Cybred","Celestial","Saurequine","Hippocampus","Kirin",
	"Cactaline","Clydesdale","Felorse","Akhal","Teke"
}
local HORSE_TAGS = { "Horse","WildHorse","Mount","Tameable" }
local SPECIES_ATTR = "Species"

local function looksHorseyName(s: string): boolean
	local low = string.lower(s)
	for _, frag in ipairs(HORSE_NAME_FRAGS) do
		if low:find(string.lower(frag), 1, true) then return true end
	end
	return false
end
local function isPlayerCharacter(m: Instance): boolean
	if not m:IsA("Model") then return false end
	if Players:GetPlayerFromCharacter(m) then return true end
	if m.Parent and m.Parent.Name == "Characters" then
		for _, p in ipairs(Players:GetPlayers()) do
			if p.Name == m.Name then return true end
		end
	end
	return false
end
local function hasAnyTag(inst: Instance, tags: {string})
	for _, t in ipairs(tags) do if CollectionService:HasTag(inst, t) then return true end end
	return false
end
local function isHorseLike(m: Instance): boolean
	if not m:IsA("Model") then return false end
	if isPlayerCharacter(m) then return false end
	if not rootOf(m) then return false end
	if hasAnyTag(m, HORSE_TAGS) then return true end
	local spec = getAttr(m, SPECIES_ATTR)
	if type(spec) == "string" and looksHorseyName(spec) then return true end
	if looksHorseyName(m.Name) then return true end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
			if t:find("tame") or t:find("mount") or t:find("ride") then return true end
		end
	end
	return false
end
local function speciesOf(m: Model): string
	local s = getAttr(m, SPECIES_ATTR)
	if type(s) == "string" and #s > 0 then return s end
	for _, frag in ipairs(HORSE_NAME_FRAGS) do
		if string.lower(m.Name):find(string.lower(frag), 1, true) then return frag end
	end
	return "Unknown"
end
local function nearestHorse(from: Vector3): (Model?, BasePart?, number)
	local bestM, bestR, bestD = nil, nil, math.huge
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Model") and isHorseLike(inst) then
			local r = rootOf(inst)
			if r then
				local d = (r.Position - from).Magnitude
				if d < bestD then bestD, bestM, bestR = d, inst, r end
			end
		end
	end
	return bestM, bestR, bestD
end
local function findTamePrompt(m: Model): ProximityPrompt?
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
			if t:find("tame") or t:find("mount") or t:find("ride") then return d end
		end
	end
	return nil
end
local successVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
local function tapKey(key: Enum.KeyCode)
	if successVIM and VIM then
		VIM:SendKeyEvent(true, key, false, game); task.wait(0.05)
		VIM:SendKeyEvent(false, key, false, game)
	end
end

-- Optional remotes (only used if present)
local TeleportRemote: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local t = rem and rem:FindFirstChild("TeleportRemote")
	return (t and t:IsA("RemoteFunction")) and t or nil
end)()
local GetTamingHorses: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local g = rem and rem:FindFirstChild("GetTamingHorses")
	return (g and g:IsA("RemoteFunction")) and g or nil
end)()

-- ===================== UI: Combined Panel =====================
local gui = Instance.new("ScreenGui")
gui.Name = "HorseMarketAndTame"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
gui.Parent = LP:WaitForChild("PlayerGui")

local panel = Instance.new("Frame")
panel.Name = "Panel"
panel.Position = UDim2.new(0, 24, 0, 80)
panel.Size = UDim2.new(0, 420, 0, 300) -- taller to fit tame section + market
panel.BackgroundColor3 = Color3.fromRGB(22,22,22)
panel.BackgroundTransparency = 0.1
panel.BorderSizePixel = 0
panel.Active = true
panel.Parent = gui

-- drag
do
	local dragging, dragStart, startPos = false, nil, nil
	panel.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true; dragStart = input.Position; startPos = panel.Position
		end
	end)
	panel.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
	end)
	UIS.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement and dragStart and startPos then
			local delta = input.Position - dragStart
			panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

-- Minimize â†’ icon
local icon = Instance.new("TextButton")
icon.Name = "MiniIcon"
icon.Size = UDim2.new(0, 40, 0, 40)
icon.Position = panel.Position
icon.Text = "ðŸª¢"
icon.Font = Enum.Font.SourceSansBold
icon.TextSize = 24
icon.BackgroundColor3 = Color3.fromRGB(35,35,35)
icon.BorderSizePixel = 0
icon.Visible = false
icon.Parent = gui
local function minimize() icon.Position = panel.Position; panel.Visible=false; icon.Visible=true end
local function restore() panel.Visible=true; icon.Visible=false end
icon.MouseButton1Click:Connect(restore)
UIS.InputBegan:Connect(function(i,g) if not g and i.KeyCode==Enum.KeyCode.J then if panel.Visible then minimize() else restore() end end end)

local minBtn = Instance.new("TextButton")
minBtn.Size = UDim2.new(0, 24, 0, 24)
minBtn.Position = UDim2.new(1, -28, 0, 4)
minBtn.Text = "â€“"
minBtn.TextScaled = true
minBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
minBtn.BorderSizePixel = 0
minBtn.Parent = panel
minBtn.MouseButton1Click:Connect(minimize)

-- ========= Tame section (TOP) =========
local tameHeader = Instance.new("TextLabel")
tameHeader.BackgroundTransparency = 1
tameHeader.Position = UDim2.new(0, 10, 0, 6)
tameHeader.Size = UDim2.new(1, -40, 0, 20)
tameHeader.Font = Enum.Font.Code
tameHeader.TextSize = 16
tameHeader.TextXAlignment = Enum.TextXAlignment.Left
tameHeader.TextColor3 = Color3.fromRGB(220,255,220)
tameHeader.Text = "Tame Mode"
tameHeader.Parent = panel

local tameToggle = Instance.new("TextButton")
tameToggle.Position = UDim2.new(0, 10, 0, 30)
tameToggle.Size = UDim2.new(0, 110, 0, 24)
tameToggle.Text = "OFF"
tameToggle.Font = Enum.Font.Code
tameToggle.TextSize = 14
tameToggle.BackgroundColor3 = Color3.fromRGB(90,40,40)
tameToggle.BorderSizePixel = 0
tameToggle.TextColor3 = Color3.fromRGB(240,240,240)
tameToggle.Parent = panel

local tameTarget = Instance.new("TextLabel")
tameTarget.BackgroundTransparency = 1
tameTarget.Position = UDim2.new(0, 130, 0, 30)
tameTarget.Size = UDim2.new(1, -140, 0, 24)
tameTarget.Font = Enum.Font.Code
tameTarget.TextSize = 14
tameTarget.TextXAlignment = Enum.TextXAlignment.Left
tameTarget.TextColor3 = Color3.fromRGB(235,235,235)
tameTarget.Text = "Target: n/a"
tameTarget.Parent = panel

local tameStatus = Instance.new("TextLabel")
tameStatus.BackgroundTransparency = 1
tameStatus.Position = UDim2.new(0, 10, 0, 56)
tameStatus.Size = UDim2.new(1, -20, 0, 20)
tameStatus.Font = Enum.Font.Code
tameStatus.TextSize = 13
tameStatus.TextXAlignment = Enum.TextXAlignment.Left
tameStatus.TextColor3 = Color3.fromRGB(200,200,200)
tameStatus.Text = "Ready."
tameStatus.Parent = panel

-- ========= Market section (BOTTOM) =========
-- Hardcoded catalog per your choice
type LassoItem = { id: string, name: string, price: number }
local Catalog: {LassoItem} = {
	{ id = "TornLasso",    name = "TornLasso",    price = 50 },
	{ id = "WesternLasso", name = "WesternLasso", price = 90 },
}
local Order: { [string]: number } = {}; for _,it in ipairs(Catalog) do Order[it.id]=0 end

local marketHeader = Instance.new("TextLabel")
marketHeader.BackgroundTransparency = 1
marketHeader.Position = UDim2.new(0, 10, 0, 84) -- under tame section
marketHeader.Size = UDim2.new(1, -20, 0, 20)
marketHeader.Font = Enum.Font.Code
marketHeader.TextSize = 16
marketHeader.TextXAlignment = Enum.TextXAlignment.Left
marketHeader.TextColor3 = Color3.fromRGB(220,255,220)
marketHeader.Text = "Lasso Market"
marketHeader.Parent = panel

local list = Instance.new("Frame")
list.BackgroundTransparency = 1
list.Position = UDim2.new(0, 10, 0, 110)
list.Size = UDim2.new(1, -20, 0, 130)
list.Parent = panel

local function mkRow(it: LassoItem, y: number)
	local r = Instance.new("Frame"); r.BackgroundTransparency = 1
	r.Size = UDim2.new(1, 0, 0, 28); r.Position = UDim2.new(0, 0, 0, y); r.Parent = list

	local nameL = Instance.new("TextLabel")
	nameL.BackgroundTransparency = 1; nameL.Position = UDim2.new(0,0,0,4)
	nameL.Size = UDim2.new(0.5,0,1,-8); nameL.Font = Enum.Font.Code; nameL.TextSize = 14
	nameL.TextXAlignment = Enum.TextXAlignment.Left; nameL.TextColor3 = Color3.fromRGB(235,235,235)
	nameL.Text = it.name; nameL.Parent = r

	local priceL = nameL:Clone()
	priceL.Position = UDim2.new(0.5,0,0,4); priceL.Size = UDim2.new(0.15,0,1,-8)
	priceL.TextColor3 = Color3.fromRGB(200,220,255); priceL.Text = tostring(it.price); priceL.Parent = r

	local minus = Instance.new("TextButton")
	minus.Position = UDim2.new(0.68,0,0,2); minus.Size = UDim2.new(0,24,0,24)
	minus.Text = "â€“"; minus.BackgroundColor3 = Color3.fromRGB(50,50,50); minus.BorderSizePixel = 0; minus.Parent = r

	local qty = Instance.new("TextBox")
	qty.Position = UDim2.new(0.78,0,0,2); qty.Size = UDim2.new(0,40,0,24)
	qty.Text = tostring(Order[it.id]); qty.ClearTextOnFocus = false
	qty.BackgroundColor3 = Color3.fromRGB(30,30,30); qty.TextColor3 = Color3.fromRGB(240,240,240)
	qty.BorderSizePixel = 0; qty.Font = Enum.Font.Code; qty.TextSize = 14; qty.Parent = r

	local plus = minus:Clone(); plus.Text = "+"; plus.Position = UDim2.new(0.78,44,0,2); plus.Parent = r

	local function clamp(n:number) return math.max(0, math.min(999, math.floor((tonumber(n) or 0)+0.0001))) end
	local function setQty(n:number) n=clamp(n); Order[it.id]=n; qty.Text=tostring(n); end
	minus.MouseButton1Click:Connect(function() setQty((Order[it.id] or 0)-1) end)
	plus.MouseButton1Click:Connect(function() setQty((Order[it.id] or 0)+1) end)
	qty.FocusLost:Connect(function() setQty(qty.Text) end)
end
for i,it in ipairs(Catalog) do mkRow(it, (i-1)*30) end

local totalL = Instance.new("TextLabel")
totalL.BackgroundTransparency = 1
totalL.Position = UDim2.new(0, 10, 1, -52)
totalL.Size = UDim2.new(0.6, 0, 0, 20)
totalL.Font = Enum.Font.Code; totalL.TextSize = 14
totalL.TextXAlignment = Enum.TextXAlignment.Left
totalL.TextColor3 = Color3.fromRGB(235,255,235)
totalL.Text = "Queued total: 0"
totalL.Parent = panel

local buyBtn = Instance.new("TextButton")
buyBtn.Position = UDim2.new(1, -110, 1, -56)
buyBtn.Size = UDim2.new(0, 100, 0, 26)
buyBtn.Text = "Buy Now"
buyBtn.Font = Enum.Font.Code; buyBtn.TextSize = 14
buyBtn.BackgroundColor3 = Color3.fromRGB(40,80,40)
buyBtn.TextColor3 = Color3.fromRGB(240,240,240)
buyBtn.BorderSizePixel = 0
buyBtn.Parent = panel

local statusL = Instance.new("TextLabel")
statusL.BackgroundTransparency = 1
statusL.Position = UDim2.new(0, 10, 1, -26)
statusL.Size = UDim2.new(1, -20, 0, 20)
statusL.Font = Enum.Font.Code; statusL.TextSize = 13
statusL.TextXAlignment = Enum.TextXAlignment.Left
statusL.TextColor3 = Color3.fromRGB(200,200,200)
statusL.Text = "Ready."
statusL.Parent = panel

-- Update queued total
local function refreshTotal()
	local t=0; for _,it in ipairs(Catalog) do t += it.price*(Order[it.id] or 0) end
	totalL.Text = "Queued total: "..tostring(t)
end
task.spawn(function() while task.wait(0.4) do refreshTotal() end end)

-- ===================== Purchase Engine =====================
local PurchaseItemRemote: RemoteFunction? = (function()
	local rem = ReplicatedStorage:FindFirstChild("Remotes")
	local r = rem and rem:FindFirstChild("PurchaseItemRemote")
	return (r and r:IsA("RemoteFunction")) and r or nil
end)()

local function setStatus(msg: string) statusL.Text = msg; print("[Market]", msg) end
local function callPurchase(itemId: string, qty: number): boolean
	if qty <= 0 then return true end
	if not PurchaseItemRemote then setStatus("PurchaseItemRemote not found."); return false end

	local variants = {
		function() return itemId, qty end,
		function() return { itemId=itemId, quantity=qty } end,
		function() return { Id=itemId, Qty=qty } end,
		function() return itemId end,
	}
	for _, build in ipairs(variants) do
		local a, b = build()
		local ok = pcall(function()
			return (PurchaseItemRemote :: RemoteFunction):InvokeServer(a,b)
		end)
		if ok then return true end
	end
	return false
end
local function buyQueued()
	local any=false; for _,it in ipairs(Catalog) do if (Order[it.id] or 0) > 0 then any=true break end end
	if not any then setStatus("Nothing to buy (all quantities are 0)."); return end
	for _, it in ipairs(Catalog) do
		local q = Order[it.id] or 0
		if q > 0 then
			setStatus(("Buying %s x%d..."):format(it.name, q))
			local ok = callPurchase(it.id, q)
			setStatus(ok and ("OK: "..it.name.." x"..q) or ("Failed: "..it.name))
		end
	end
end
buyBtn.MouseButton1Click:Connect(buyQueued)
_G.TriggerLassoPurchase = function() buyQueued() end

-- ===================== Tame Logic =====================
-- ====== REMOTE DISCOVERY ======
local Remotes = game:GetService("ReplicatedStorage"):FindFirstChild("Remotes")

local TeleportRemote = Remotes and Remotes:FindFirstChild("TeleportRemote")
local GetTamingHorsesRE = Remotes and Remotes:FindFirstChild("GetTamingHorses") -- RemoteEvent
local RideRemote = (function()
    if not Remotes then return nil end
    for _, r in ipairs(Remotes:GetChildren()) do
        local n = r.Name:lower()
        if (n:find("ride") or n:find("mount")) and (r:IsA("RemoteEvent") or r:IsA("RemoteFunction")) then
            return r
        end
    end
    return nil
end)()

local StartTameRemote = (function()
    if not Remotes then return nil end
    for _, r in ipairs(Remotes:GetChildren()) do
        local n = r.Name:lower()
        if (n:find("tame") or n:find("starttame") or n:find("begin")) and (r:IsA("RemoteEvent") or r:IsA("RemoteFunction")) then
            return r
        end
    end
    return nil
end)()

local SellHorseRemote = (function()
    if not Remotes then return nil end
    for _, r in ipairs(Remotes:GetChildren()) do
        local n = r.Name:lower()
        if (n:find("sell") and n:find("horse")) and (r:IsA("RemoteEvent") or r:IsA("RemoteFunction")) then
            return r
        end
    end
    return nil
end)()

local function safeInvoke(remote, a, b)
    if not remote then return false, "no-remote" end
    local ok, res = pcall(function()
        if remote:IsA("RemoteFunction") then
            return remote:InvokeServer(a, b)
        else
            remote:FireServer(a, b)
            return true
        end
    end)
    return ok, res
end

-- ====== TELEPORT UTIL (try multiple payload shapes) ======
local function teleportTo(pos: Vector3)
    if TeleportRemote then
        local tried = {
            function() return pos end,                                  -- Vector3
            function() return CFrame.new(pos) end,                      -- CFrame
            function() return {Position = pos} end,                     -- table
        }
        for _, build in ipairs(tried) do
            local a = build()
            local ok = safeInvoke(TeleportRemote, a)
            if ok then return true end
        end
    end
    -- Fallback: client-set (might rubberband)
    local hrp = (LP.Character and LP.Character:FindFirstChild("HumanoidRootPart"))
    if hrp then
        hrp.CFrame = CFrame.new(pos)
        return true
    end
    return false
end

-- ====== RIDE / TAME / SELL HELPERS ======
local function setRideState(target: Model?)
    if not target or not RideRemote then return end
    -- try (target) or {horse=target}
    safeInvoke(RideRemote, target)
    safeInvoke(RideRemote, {horse = target})
end

local function startTame(target: Model?)
    if not target then return end
    -- press the proximity prompt too (UI method)
    local prompt
    for _, d in ipairs(target:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
            if t:find("tame") or t:find("mount") or t:find("ride") then prompt = d break end
        end
    end
    if prompt and prompt.Enabled then
        local successVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
        if successVIM and VIM then
            local key = prompt.KeyboardKeyCode or Enum.KeyCode.E
            VIM:SendKeyEvent(true, key, false, game); task.wait(0.05)
            VIM:SendKeyEvent(false, key, false, game)
        end
    end
    -- also try a server signal if present
    if StartTameRemote then
        safeInvoke(StartTameRemote, target)
        safeInvoke(StartTameRemote, {horse = target})
    end
end

local function sellHorse(target: Model?)
    if not target or not SellHorseRemote then return end
    local name = target:GetAttribute("NameKey") or target.Name
    -- try common shapes: (model), (id/name), {horse=...}, {id=...}
    safeInvoke(SellHorseRemote, target)
    safeInvoke(SellHorseRemote, {horse = target})
    safeInvoke(SellHorseRemote, tostring(name))
    safeInvoke(SellHorseRemote, {id = tostring(name)})
end

-- ====== OPTIONAL: Inspect GetTamingHorses via V key ======
if GetTamingHorsesRE then
    GetTamingHorsesRE.OnClientEvent:Connect(function(...)
        print("[GetTamingHorses][OnClientEvent] payload:", ...)
        -- If the server actually sends a list back, you can parse it here
    end)
end
game:GetService("UserInputService").InputBegan:Connect(function(input, gpe)
    if not gpe and input.KeyCode == Enum.KeyCode.V then
        if GetTamingHorsesRE then
            print("[V] Firing GetTamingHorses (RemoteEvent)")
            safeInvoke(GetTamingHorsesRE) -- FireServer()
        else
            warn("[V] GetTamingHorses not found (as RemoteEvent)")
        end
    end
end)

-- ====== TAME STATE ======
local TAME_ACTIVE = false
local TARGET: Model? = nil
local TARGET_ROOT: BasePart? = nil
local function setTameActive(v: boolean)
    TAME_ACTIVE = v
    tameToggle.Text = v and "ON" or "OFF"
    tameToggle.BackgroundColor3 = v and Color3.fromRGB(40,90,40) or Color3.fromRGB(90,40,40)
    tameStatus.Text = v and "Seeking nearest horseâ€¦" or "Paused."
    if not v then
        TARGET, TARGET_ROOT = nil, nil
        local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = false end
        tameTarget.Text = "Target: n/a"
    end
end
tameToggle.MouseButton1Click:Connect(function() setTameActive(not TAME_ACTIVE) end)

-- ====== PATCHED TAME LOOP ======
task.spawn(function()
    while true do
        task.wait(0.25)
        if not TAME_ACTIVE then continue end

        local hrp = (LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")) :: BasePart?
        if not hrp then continue end

        -- target selection (keep your nearestHorse() elsewhere in script)
        if (not TARGET) or (not TARGET.Parent) then
            local _, r, d = nearestHorse(hrp.Position)
            TARGET, TARGET_ROOT = _, r
            if TARGET and TARGET_ROOT then
                tameTarget.Text = string.format("Target: %s (%.1f)", speciesOf(TARGET), (TARGET_ROOT.Position - hrp.Position).Magnitude)
                tameStatus.Text = "Target acquired."
            else
                tameTarget.Text = "Target: n/a"; tameStatus.Text = "No horse found."
            end
        end
        if not TARGET or not TARGET_ROOT then continue end

        -- 1) make character "ride" (best-effort)
        setRideState(TARGET)

        -- 2) teleport on top of horse and lock
        local mountPos = TARGET_ROOT.Position + Vector3.new(0, 2, 0)
        teleportTo(mountPos)
        if hrp then hrp.Anchored = true end

        -- 3) start taming actively
        startTame(TARGET)
        tameStatus.Text = "Tamingâ€¦"

        -- 4) success check
        local tamed = getAttr(TARGET, "Tamed")
        local owner = getAttr(TARGET, "Owner") or getAttr(TARGET, "OwnerName")
        if tamed == true or owner == LP.Name then
            tameStatus.Text = "Tamed! Sellingâ€¦"
            if hrp then hrp.Anchored = false end
            -- 5) sell
            sellHorse(TARGET)
            setTameActive(false)
        end
    end
end)
