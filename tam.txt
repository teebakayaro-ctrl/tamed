--!strict
-- Tame Flow: Toggleable “Tame Mode” that targets nearest horse, approaches, and interacts.
-- On success (Tamed/Owner set), it triggers queued lasso purchase via _G.TriggerLassoPurchase().

local Players                 = game:GetService("Players")
local CollectionService       = game:GetService("CollectionService")
local ProximityPromptService  = game:GetService("ProximityPromptService")
local ReplicatedStorage       = game:GetService("ReplicatedStorage")
local RunService              = game:GetService("RunService")
local UIS                     = game:GetService("UserInputService")

local LP = Players.LocalPlayer

-- =========================
-- ====== CONFIG ===========
-- =========================
local CFG = {
    SCAN_INTERVAL = 0.25,
    FOLLOW_RANGE  = 18,       -- we try to stay within this distance
    REPATH_RANGE  = 45,       -- if we drift beyond this, we try teleport (if available) or speed up
    SPECIES_ATTR  = "Species",
    NAME_MATCH = { "Horse","Unicorn","Gargoyle","Equus","Bisorse","Pony","Caprine","Kelpie","Peryton","Fae",
                   "Plush","Flora","Cybred","Celestial","Saurequine","Hippocampus","Kirin","Cactaline","Clydesdale","Felorse","Akhal","Teke" },
    TAGS = { "Horse","WildHorse","Mount","Tameable" },
    UI_POS = UDim2.new(0, 24, 0, 320),
}

-- =========================
-- ====== HELPERS ==========
-- =========================
local function char() return LP.Character or LP.CharacterAdded:Wait() end
local function rootOf(m: Model): BasePart?
    return m:FindFirstChild("HumanoidRootPart") or m:FindFirstChild("Torso") or m:FindFirstChildWhichIsA("BasePart")
end
local function myRoot(): BasePart?
    local c = char()
    return rootOf(c)
end
local function isPlayerCharacter(m: Instance): boolean
    if not m:IsA("Model") then return false end
    if Players:GetPlayerFromCharacter(m) then return true end
    if m.Parent and m.Parent.Name == "Characters" then
        for _, p in ipairs(Players:GetPlayers()) do
            if p.Name == m.Name then return true end
        end
    end
    return false
end
local function hasAnyTag(inst: Instance, tags: {string})
    for _, t in ipairs(tags) do if CollectionService:HasTag(inst, t) then return true end end
    return false
end
local function looksHorseyName(s: string): boolean
    local low = string.lower(s)
    for _, frag in ipairs(CFG.NAME_MATCH) do
        if low:find(string.lower(frag)) then return true end
    end
    return false
end
local function getAttr(inst: Instance, k: string)
    local ok, v = pcall(function() return inst:GetAttribute(k) end)
    return ok and v or nil
end
local function isHorseLike(m: Instance): boolean
    if not m:IsA("Model") then return false end
    if isPlayerCharacter(m) then return false end
    if not rootOf(m) then return false end
    if hasAnyTag(m, CFG.TAGS) then return true end
    local spec = getAttr(m, CFG.SPECIES_ATTR)
    if type(spec) == "string" and looksHorseyName(spec) then return true end
    if looksHorseyName(m.Name) then return true end
    for _, d in ipairs(m:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
            if t:find("tame") or t:find("mount") or t:find("ride") then return true end
        end
    end
    return false
end

local function nearestHorse(from: Vector3): (Model?, BasePart?, number)
    local bestM, bestR, bestD = nil, nil, math.huge
    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA("Model") and isHorseLike(inst) then
            local r = rootOf(inst)
            if r then
                local d = (r.Position - from).Magnitude
                if d < bestD then bestD, bestM, bestR = d, inst, r end
            end
        end
    end
    return bestM, bestR, bestD
end

local function speciesOf(m: Model): string
    local s = getAttr(m, CFG.SPECIES_ATTR)
    if type(s) == "string" and #s > 0 then return s end
    for _, frag in ipairs(CFG.NAME_MATCH) do
        if string.lower(m.Name):find(string.lower(frag)) then return frag end
    end
    return "Unknown"
end

local function findTamePrompt(m: Model): ProximityPrompt?
    for _, d in ipairs(m:GetDescendants()) do
        if d:IsA("ProximityPrompt") then
            local t = string.lower((d.ActionText or "") .. " " .. (d.ObjectText or ""))
            if t:find("tame") or t:find("mount") or t:find("ride") then
                return d
            end
        end
    end
    return nil
end

local successVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)

local function tryPress(key: Enum.KeyCode)
    if successVIM and VIM then
        VIM:SendKeyEvent(true, key, false, game); task.wait(0.05)
        VIM:SendKeyEvent(false, key, false, game)
    end
end

-- Optional server helpers (best-effort)
local TeleportRemote: RemoteFunction? = nil
local GetTamingHorses: RemoteFunction? = nil
do
    local rem = ReplicatedStorage:FindFirstChild("Remotes")
    if rem then
        local t = rem:FindFirstChild("TeleportRemote")
        if t and t:IsA("RemoteFunction") then TeleportRemote = t end
        local g = rem:FindFirstChild("GetTamingHorses")
        if g and g:IsA("RemoteFunction") then GetTamingHorses = g end
    end
end

local function serverTeleportTo(pos: Vector3)
    if not TeleportRemote then return false end
    local ok = pcall(function()
        -- Many games expect a position or a named location; here we try position.
        TeleportRemote:InvokeServer(pos)
    end)
    return ok
end

-- =========================
-- ====== UI ===============
-- =========================
local gui = Instance.new("ScreenGui")
gui.Name = "TameFlowUI"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = LP:WaitForChild("PlayerGui")

local panel = Instance.new("Frame")
panel.Position = CFG.UI_POS
panel.Size = UDim2.new(0, 280, 0, 88)
panel.BackgroundColor3 = Color3.fromRGB(22,22,22)
panel.BackgroundTransparency = 0.12
panel.BorderSizePixel = 0
panel.Active = true
panel.Parent = gui

-- drag panel
do
    local dragging, start, startPos = false, nil, nil
    panel.InputBegan:Connect(function(i)
        if i.UserInputType==Enum.UserInputType.MouseButton1 then
            dragging = true; start = i.Position; startPos = panel.Position
        end
    end)
    panel.InputEnded:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then dragging=false end end)
    UIS.InputChanged:Connect(function(i)
        if dragging and i.UserInputType==Enum.UserInputType.MouseMovement and start and startPos then
            local d = i.Position - start
            panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + d.X, startPos.Y.Scale, startPos.Y.Offset + d.Y)
        end
    end)
end

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Position = UDim2.new(0,10,0,6)
title.Size = UDim2.new(1,-20,0,18)
title.Font = Enum.Font.Code
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(220,255,220)
title.Text = "Tame Mode"
title.Parent = panel

local toggleBtn = Instance.new("TextButton")
toggleBtn.Position = UDim2.new(0,10,0,32)
toggleBtn.Size = UDim2.new(0, 110, 0, 24)
toggleBtn.Text = "OFF"
toggleBtn.Font = Enum.Font.Code
toggleBtn.TextSize = 14
toggleBtn.BackgroundColor3 = Color3.fromRGB(90,40,40)
toggleBtn.BorderSizePixel = 0
toggleBtn.TextColor3 = Color3.fromRGB(240,240,240)
toggleBtn.Parent = panel

local targetL = Instance.new("TextLabel")
targetL.BackgroundTransparency = 1
targetL.Position = UDim2.new(0,130,0,32)
targetL.Size = UDim2.new(1,-140,0,24)
targetL.Font = Enum.Font.Code
targetL.TextSize = 14
targetL.TextXAlignment = Enum.TextXAlignment.Left
targetL.TextColor3 = Color3.fromRGB(235,235,235)
targetL.Text = "Target: n/a"
targetL.Parent = panel

local statusL = Instance.new("TextLabel")
statusL.BackgroundTransparency = 1
statusL.Position = UDim2.new(0,10,0,58)
statusL.Size = UDim2.new(1,-20,0,22)
statusL.Font = Enum.Font.Code
statusL.TextSize = 13
statusL.TextXAlignment = Enum.TextXAlignment.Left
statusL.TextColor3 = Color3.fromRGB(200,200,200)
statusL.Text = "Ready."
statusL.Parent = panel

local active = false
local currentTarget: Model? = nil
local currentRoot: BasePart? = nil

local function setActive(v: boolean)
    active = v
    toggleBtn.Text = v and "ON" or "OFF"
    toggleBtn.BackgroundColor3 = v and Color3.fromRGB(40,90,40) or Color3.fromRGB(90,40,40)
    statusL.Text = v and "Seeking nearest horse…" or "Paused."
end

toggleBtn.MouseButton1Click:Connect(function() setActive(not active) end)

-- =========================
-- ====== MAIN LOOP ========
-- =========================
task.spawn(function()
    local myH = char():WaitForChild("Humanoid") :: Humanoid
    myH.AutoRotate = true
    myH.WalkSpeed = 16

    while true do
        task.wait(CFG.SCAN_INTERVAL)
        local hrp = myRoot()
        if not hrp then continue end

        if not active then
            currentTarget = nil; currentRoot = nil
            targetL.Text = "Target: n/a"
            continue
        end

        -- If no target, pick the nearest (or use GetTamingHorses list if present)
        if (not currentTarget) or (not currentTarget.Parent) then
            local target, tRoot, dist = nil, nil, math.huge
            if GetTamingHorses then
                local ok, list = pcall(function() return GetTamingHorses:InvokeServer() end)
                if ok and typeof(list) == "table" then
                    for _, m in ipairs(list) do
                        if typeof(m) == "Instance" and m:IsA("Model") and isHorseLike(m) then
                            local r = rootOf(m)
                            if r then
                                local d = (r.Position - hrp.Position).Magnitude
                                if d < dist then dist, target, tRoot = d, m, r end
                            end
                        end
                    end
                end
            end
            if not target then
                target, tRoot, dist = nearestHorse(hrp.Position)
            end
            currentTarget, currentRoot = target, tRoot
            if target and tRoot then
                targetL.Text = string.format("Target: %s (%.1f)", speciesOf(target), (tRoot.Position - hrp.Position).Magnitude)
                statusL.Text = "Target acquired."
            else
                targetL.Text = "Target: n/a"
                statusL.Text = "No horse found nearby."
            end
        end

        if currentTarget and currentRoot and currentTarget.Parent then
            -- approach / follow
            local dist = (currentRoot.Position - hrp.Position).Magnitude

            -- If very far and we have TeleportRemote, try a one-time jump near it
            if dist > CFG.REPATH_RANGE and TeleportRemote then
                statusL.Text = "Far away. Teleporting near target…"
                -- offset a bit below/aside to avoid overlap; server may clamp
                local targetPos = currentRoot.Position + Vector3.new(0, 0, -4)
                pcall(function() serverTeleportTo(targetPos) end)
            end

            -- Move closer until within FOLLOW_RANGE
            if dist > CFG.FOLLOW_RANGE then
                local dir = (currentRoot.Position - hrp.Position); dir = Vector3.new(dir.X, 0, dir.Z)
                if dir.Magnitude > 1e-2 then
                    myH:Move(dir.Unit)
                end
            else
                myH:Move(Vector3.new(0,0,0))
            end

            -- face target for prompts
            hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(currentRoot.Position.X, hrp.Position.Y, currentRoot.Position.Z))

            -- Try to interact with a Tame/Mount prompt if in range
            local prompt = findTamePrompt(currentTarget)
            if prompt and prompt.Enabled then
                local key = prompt.KeyboardKeyCode or Enum.KeyCode.E
                tryPress(key)
                statusL.Text = "Interacting with prompt…"
            end

            -- Check success: Tamed or Owner set to us
            local tamed = getAttr(currentTarget, "Tamed")
            local owner = getAttr(currentTarget, "Owner") or getAttr(currentTarget, "OwnerName")
            if tamed == true or owner == LP.Name then
                statusL.Text = "Tame success! Triggering queued purchases…"
                -- fire your queued purchase now
                if _G.TriggerLassoPurchase then
                    _G.TriggerLassoPurchase()
                end
                -- stop the loop & clear target
                setActive(false)
                currentTarget, currentRoot = nil, nil
            else
                -- keep UI updated
                targetL.Text = string.format("Target: %s (%.1f)", speciesOf(currentTarget), dist)
            end
        end
    end
end)
