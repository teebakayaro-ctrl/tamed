-- === Targeted Tame Sender ===========================================
-- call GetTamingHorses (RemoteEvent), then send chosen horse 'target'
-- into likely tame/mount remotes with several payload shapes.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local LP = Players.LocalPlayer

-- helpers you already have in your script; keep if not present
local function rootOf(m: Model): BasePart?
    return m:FindFirstChild("HumanoidRootPart") or m:FindFirstChild("Torso") or m:FindFirstChildWhichIsA("BasePart")
end
local function isPlayerCharacter(m: Instance): boolean
    return m:IsA("Model") and Players:GetPlayerFromCharacter(m) ~= nil
end
local function isHorseLike(m: Instance): boolean
    if not m:IsA("Model") or isPlayerCharacter(m) then return false end
    if not rootOf(m) then return false end
    -- very loose check; replace with your own if you already have one
    local n = m.Name:lower()
    for _, frag in ipairs({ "horse","unicorn","gargoyle","equus","bisorse","pony","caprine","kelpie","peryton","fae","flora","clydesdale","kirin","hippocampus","saurequine","felorse","akhal","teke","cactaline","plush","cybred","celestial" }) do
        if n:find(frag, 1, true) then return true end
    end
    return false
end
local function nearestHorse(from: Vector3): (Model?, BasePart?, number)
    local bestM, bestR, bestD = nil, nil, math.huge
    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA("Model") and isHorseLike(inst) then
            local r = rootOf(inst)
            if r then
                local d = (r.Position - from).Magnitude
                if d < bestD then bestD, bestM, bestR = d, inst, r end
            end
        end
    end
    return bestM, bestR, bestD
end

-- locate remotes
local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
local GetTamingHorsesRE = Remotes and Remotes:FindFirstChild("GetTamingHorses")  -- (RemoteEvent)
-- collect all "tame/mount/ride" remotes anywhere under ReplicatedStorage (and common subfolders)
local function collectTameRemotes(): {Instance}
    local out = {}
    local keywords = { "tame","starttame","mount","ride","begin" }
    local roots = { ReplicatedStorage }
    for _, root in ipairs(roots) do
        for _, d in ipairs(root:GetDescendants()) do
            if d:IsA("RemoteEvent") or d:IsA("RemoteFunction") then
                local n = d.Name:lower()
                local hit = false
                for _, k in ipairs(keywords) do
                    if n:find(k, 1, true) then hit = true break end
                end
                if hit then table.insert(out, d) end
            end
        end
    end
    return out
end

local function safeInvoke(remote: Instance, a, b)
    local ok, res = pcall(function()
        if remote:IsA("RemoteFunction") then
            return remote:InvokeServer(a, b)
        else
            (remote :: RemoteEvent):FireServer(a, b)
            return true
        end
    end)
    return ok, res
end

-- Send 'target' to all candidate remotes with multiple payload shapes
local function sendTargetToTameRemotes(target: Model)
    local candidates = collectTameRemotes()
    if #candidates == 0 then
        warn("[TameSender] no tame/mount remotes found under ReplicatedStorage (try scanning _replicationFolder / Workspace too)")
        return false
    end
    local tried = 0
    for _, r in ipairs(candidates) do
        local name = r:GetFullName()
        -- try a few payload shapes
        local payloads = {
            function() return target end,
            function() return {horse = target} end,
            function() return {target = target} end,
            function() return {model = target} end,
            function() return target, "tame" end,
            function() return "tame", target end,
        }
        for i, build in ipairs(payloads) do
            tried += 1
            local a, b = build()
            local ok, res = safeInvoke(r, a, b)
            if ok then
                print(("[TameSender] OK via %s (variant #%d)"):format(name, i))
                return true
            end
        end
    end
    warn(("[TameSender] all attempts failed on %d remotes × payloads"):format(#candidates))
    return false
end

-- Call GetTamingHorses properly (RemoteEvent) – optional “priming” step
local function callGetTamingHorses()
    if GetTamingHorsesRE and GetTamingHorsesRE:IsA("RemoteEvent") then
        local ok = pcall(function() GetTamingHorsesRE:FireServer() end)
        print("[TameSender] GetTamingHorses fired:", ok)
    else
        warn("[TameSender] GetTamingHorses RemoteEvent not found (or not an RE)")
    end
end

-- Hotkeys:
--   V = just call GetTamingHorses (prime)
--   B = prime + choose nearest horse + send target to candidate remotes
UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.V then
        callGetTamingHorses()
    elseif input.KeyCode == Enum.KeyCode.B then
        callGetTamingHorses()
        task.delay(0.1, function()
            local c = LP.Character or LP.CharacterAdded:Wait()
            local hrp = c:FindFirstChild("HumanoidRootPart")
            if not hrp then warn("[TameSender] no HRP"); return end
            local h, r, d = nearestHorse(hrp.Position)
            if not h then warn("[TameSender] no horse found nearby"); return end
            print(("[TameSender] target: %s (%.1f studs)"):format(h.Name, (r.Position - hrp.Position).Magnitude))
            sendTargetToTameRemotes(h)
        end)
    end
end)
