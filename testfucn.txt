-- GLOBAL REMOTE SPY v1.2-mini (no bindables; nil-safe)
-- Logs ALL RemoteEvent/RemoteFunction Fire*/Invoke* calls across the game.
-- Stores recent logs in _G.REMOTE_SPY_LOGS. Helpers: RemoteSpyGet(n), RemoteSpyFilter(substr,n), RemoteSpyClear().

local MAX_LOGS = 1000
local PREVIEW_MAX = 6

-- ---- compat shims ----
local has_hook = (type(hookmetamethod) == "function")
local has_getname = (type(getnamecallmethod) == "function")
local has_check = (type(checkcaller) == "function")
local getNC = has_getname and getnamecallmethod or function() return "" end
local isCaller = has_check and checkcaller or function() return false end

_G.REMOTE_SPY_LOGS = _G.REMOTE_SPY_LOGS or {}

local function pushLog(e)
    table.insert(_G.REMOTE_SPY_LOGS, 1, e)
    if #_G.REMOTE_SPY_LOGS > MAX_LOGS then
        for i = MAX_LOGS+1, #_G.REMOTE_SPY_LOGS do _G.REMOTE_SPY_LOGS[i] = nil end
    end
end

local function safeToStr(v)
    local t = typeof(v)
    if t == "Instance" then
        local ok, full = pcall(function() return v:GetFullName() end)
        return ok and ("<%s:%s>"):format(v.ClassName, full) or ("<%s>" ):format(v.ClassName)
    end
    local ok, s = pcall(function() return tostring(v) end)
    return ok and s or ("<unprintable:%s>"):format(t)
end

local function previewFromPack(p)
    local n = p.n or #p
    local parts = {}
    local cap = math.min(n, PREVIEW_MAX)
    for i = 1, cap do parts[i] = safeToStr(p[i]) end
    if n > PREVIEW_MAX then parts[#parts+1] = ("...(+%d)"):format(n - PREVIEW_MAX) end
    return table.concat(parts, ", ")
end

local function shortStack()
    local ok, tb = pcall(function() return debug.traceback("", 3) end)
    if not ok or not tb then return "" end
    local k, out = 0, {}
    for line in tb:gmatch("[^\n]+") do
        k = k + 1; out[#out+1] = line
        if k >= 5 then break end
    end
    return table.concat(out, " | ")
end

-- ---- hook via hookmetamethod (preferred) ----
local hooked = false
if has_hook then
    local original = hookmetamethod(game, "__namecall", function(self, ...)
        local m = getNC()
        if m == "FireServer" or m == "FireClient" or m == "FireAllClients" or m == "InvokeServer" or m == "InvokeClient" then
            local pack = table.pack(...)
            local entry = {
                time = os.time(),
                method = m,
                receiver = (typeof(self) == "Instance" and (pcall(function() return self:GetFullName() end) and self:GetFullName())) or tostring(self),
                class = (typeof(self) == "Instance" and self.ClassName) or typeof(self),
                argsPreview = previewFromPack(pack),
                originIsScript = isCaller(),
                stack = shortStack(),
            }

            if m:sub(1,6) == "Invoke" then
                local ok, r1, r2, r3 = pcall(original, self, ...)
                entry.invokeSuccess = ok
                if ok then entry.returnsPreview = previewFromPack(table.pack(r1, r2, r3)) end
                pushLog(entry)
                print(("[REMOTE-SPY] %s -> %s | [%s] | ok=%s | ret=[%s]"):format(entry.receiver or "?", m, entry.argsPreview or "", tostring(ok), entry.returnsPreview or ""))
                if ok then return r1, r2, r3 else error(tostring(r1)) end
            else
                local ok, err = pcall(original, self, ...)
                entry.fireSuccess = ok
                if not ok then entry.error = tostring(err) end
                pushLog(entry)
                print(("[REMOTE-SPY] %s -> %s | [%s] | ok=%s"):format(entry.receiver or "?", m, entry.argsPreview or "", tostring(ok)))
                return
            end
        end
        return original(self, ...)
    end)

    -- some executors return nil instead of the original (bad!); guard that:
    if type(original) == "function" then
        hooked = true
    else
        warn("[REMOTE-SPY] hookmetamethod returned nil; disabling this path.")
    end
end

-- ---- raw metatable fallback (only if safe) ----
if not hooked then
    local ok_mt, mt = pcall(getrawmetatable, game)
    if ok_mt and mt and type(mt.__namecall) == "function" then
        local old = mt.__namecall
        local canWrite = (type(setreadonly) == "function")
        if canWrite then pcall(setreadonly, mt, false) end
        mt.__namecall = (type(newcclosure) == "function" and newcclosure or function(f) return f end)(function(self, ...)
            local m = getNC()
            if m == "FireServer" or m == "FireClient" or m == "FireAllClients" or m == "InvokeServer" or m == "InvokeClient" then
                local pack = table.pack(...)
                local entry = {
                    time = os.time(),
                    method = m,
                    receiver = (typeof(self) == "Instance" and (pcall(function() return self:GetFullName() end) and self:GetFullName())) or tostring(self),
                    class = (typeof(self) == "Instance" and self.ClassName) or typeof(self),
                    argsPreview = previewFromPack(pack),
                    originIsScript = isCaller(),
                    stack = shortStack(),
                }
                if m:sub(1,6) == "Invoke" then
                    local ok2, r1, r2, r3 = pcall(old, self, ...)
                    entry.invokeSuccess = ok2
                    if ok2 then entry.returnsPreview = previewFromPack(table.pack(r1, r2, r3)) end
                    pushLog(entry)
                    print(("[REMOTE-SPY] %s -> %s | [%s] | ok=%s | ret=[%s]"):format(entry.receiver or "?", m, entry.argsPreview or "", tostring(ok2), entry.returnsPreview or ""))
                    if ok2 then return r1, r2, r3 else error(tostring(r1)) end
                else
                    local ok2, err = pcall(old, self, ...)
                    entry.fireSuccess = ok2
                    if not ok2 then entry.error = tostring(err) end
                    pushLog(entry)
                    print(("[REMOTE-SPY] %s -> %s | [%s] | ok=%s"):format(entry.receiver or "?", m, entry.argsPreview or "", tostring(ok2)))
                    return
                end
            end
            return old(self, ...)
        end)
        if canWrite then pcall(setreadonly, mt, true) end
        hooked = true
    end
end

if not hooked then
    warn("[REMOTE-SPY] Could not hook __namecall (no working hookmetamethod and raw __namecall unavailable). Your executor likely doesnâ€™t support call interception.")
else
    print("[REMOTE-SPY] Active. Logging RemoteEvent/RemoteFunction Fire*/Invoke* across game.")
end

-- ---- helpers ----
_G.RemoteSpyGet = function(n)
    n = n or 50
    local out = {}
    for i=1, math.min(n, #_G.REMOTE_SPY_LOGS) do out[i] = _G.REMOTE_SPY_LOGS[i] end
    return out
end
_G.RemoteSpyFilter = function(substr, n)
    n = n or 100
    local res = {}
    for i=1, #_G.REMOTE_SPY_LOGS do
        local e = _G.REMOTE_SPY_LOGS[i]
        if e and (
            (e.receiver and tostring(e.receiver):find(substr, 1, true)) or
            (e.method and tostring(e.method):find(substr, 1, true))
        ) then
            res[#res+1] = e
            if #res >= n then break end
        end
    end
    return res
end
_G.RemoteSpyClear = function()
    _G.REMOTE_SPY_LOGS = {}
    print("[REMOTE-SPY] cleared.")
end
