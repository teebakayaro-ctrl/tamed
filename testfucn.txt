-- Lasso Deep Inspector v2 — finds & wraps local doLasso/_hit by crawling closures/upvalues
-- Minimal noise: prints only when doLasso/_hit run. Stores last args/returns in globals.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ---------- helpers ----------
local function full(i) local ok,f=pcall(function() return i:GetFullName() end); return ok and f or tostring(i) end
local function pretty(v)
    local t = typeof(v)
    if t=="Instance" then
        local okN,nm=pcall(function() return v.Name end)
        return ("<%s:%s>"):format(v.ClassName, okN and nm or "?")
    else
        local ok,s=pcall(function() return tostring(v) end)
        return ok and s or ("<"..t..">")
    end
end
local function packArgs(...) local p=table.pack(...); return p end
local function previewPack(p, cap)
    cap = cap or 5
    local n = p.n or #p
    local parts = {}
    for i=1, math.min(n, cap) do parts[i] = ("[%d] %s"):format(i, pretty(p[i])) end
    if n > cap then parts[#parts+1] = ("...(+%d)"):format(n-cap) end
    return table.concat(parts, "  ")
end

-- ---------- locate modules ----------
local root = ReplicatedStorage:FindFirstChild("_replicationFolder", true)
if not root then return warn("[LDI] _replicationFolder not found") end

local lassoMS = root:FindFirstChild("Lasso", true)
if not (lassoMS and lassoMS:IsA("ModuleScript")) then return warn("[LDI] Lasso ModuleScript not found") end

local mobMS = root:FindFirstChild("MobAnimator", true) -- seen in your stack
-- mobMS optional; we’ll use it if available

local okL, LassoRet = pcall(require, lassoMS)
if not okL then return warn("[LDI] require(Lasso) failed: "..tostring(LassoRet)) end

local okM, MobRet = true, nil
if mobMS then okM, MobRet = pcall(require, mobMS) end

local LASSO_SRC = lassoMS:GetFullName() -- used to match debug.info(fn,"s")

-- ---------- closure crawler ----------
local seenFunc, seenTable = {}, {}
local owners = {}        -- map: targetFn -> list of {kind="upvalue"/"table", owner=function/table, keyOrIndex=...}
local targets = { }      -- map name -> function (we keep both doLasso and _hit if found)

local function markOwner(targetFn, kind, owner, keyOrIndex)
    owners[targetFn] = owners[targetFn] or {}
    table.insert(owners[targetFn], {kind=kind, owner=owner, key=keyOrIndex})
end

local function crawlValue(val, fromKind, owner, key)
    local t = typeof(val)
    if t == "table" then
        if seenTable[val] then return end
        seenTable[val] = true
        for k,v in pairs(val) do
            if typeof(v) == "function" then
                -- record table slot in case this is target later
                local src = debug.info(v, "s") or ""
                local nm  = debug.info(v, "n") or ""
                if type(nm)=="string" and #nm>0 and src:find(LASSO_SRC, 1, true) then
                    -- candidate by name & source
                    if nm=="doLasso" or nm=="_hit" then
                        targets[nm] = targets[nm] or v
                        markOwner(v, "table", val, k)
                    end
                end
            end
            crawlValue(v, "table", val, k)
        end
    elseif t == "function" then
        if seenFunc[val] then return end
        seenFunc[val] = true

        -- identify functions that belong to the Lasso module by source
        local src = debug.info(val, "s") or ""
        local nm  = debug.info(val, "n") or ""
        if src:find(LASSO_SRC, 1, true) then
            -- if we arrived here from a table/owner, remember the slot; we’ll also scan upvalues
            if (nm=="doLasso" or nm=="_hit") and owner ~= nil then
                -- record this function reference back to its container
                markOwner(val, fromKind, owner, key)
                targets[nm] = targets[nm] or val
            end
        end

        -- crawl upvalues; also watch for upvalue names matching doLasso/_hit
        local i = 1
        while true do
            local upName, upVal = debug.getupvalue(val, i)
            if not upName then break end
            if typeof(upVal) == "function" then
                local usrc = debug.info(upVal, "s") or ""
                local un   = debug.info(upVal, "n") or ""
                if usrc:find(LASSO_SRC, 1, true) then
                    if upName=="doLasso" or upName=="_hit" or un=="doLasso" or un=="_hit" then
                        targets[upName=="doLasso" and "doLasso" or (upName=="_hit" and "_hit" or (un~="" and un or upName))] = targets[upName] or upVal
                        markOwner(upVal, "upvalue", val, i) -- upvalue slot to replace
                    end
                end
            end
            -- continue crawling
            crawlValue(upVal, "upvalue", val, i)
            i = i + 1
        end
    end
end

-- seed the crawl with everything reachable from both require returns
crawlValue(LassoRet, "root", nil, nil)
if okM and MobRet ~= nil then crawlValue(MobRet, "root", nil, nil) end

-- if names not yet found, still attempt: any function from Lasso source reachable?
if not targets.doLasso or not targets._hit then
    for fn,_ in pairs(seenFunc) do
        local src = debug.info(fn,"s") or ""
        local nm  = debug.info(fn,"n") or ""
        if src:find(LASSO_SRC,1,true) then
            if nm=="doLasso" then targets.doLasso = targets.doLasso or fn end
            if nm=="_hit"    then targets._hit    = targets._hit    or fn end
        end
    end
end

-- ---------- install wrappers ----------
local function makeWrapper(name, orig)
    local pCount, isVar = debug.info(orig, "a")
    print(("[LDI] Wrapping %s  params=%s vararg=%s"):format(name, tostring(pCount), tostring(isVar)))
    return function(...)
        local args = packArgs(...)
        _G["LASSO_LASTARGS_"..name] = args
        print(("[%s] args -> %s"):format(name, previewPack(args, 6)))
        local ret = table.pack(orig(...))
        _G["LASSO_LASTRET_"..name] = ret
        if ret.n > 0 then
            print(("[%s] returns -> %s"):format(name, previewPack(ret, 6)))
        end
        return table.unpack(ret, 1, ret.n)
    end
end

local function replaceEverywhere(targetName, targetFn)
    if not targetFn then return end
    local wrapper = makeWrapper(targetName, targetFn)

    -- 1) Try hookfunction if executor supports it
    local okHook = false
    if type(hookfunction)=="function" then
        local ok, err = pcall(function() hookfunction(targetFn, wrapper) end)
        okHook = ok
    end

    -- 2) Also patch all recorded owners (upvalue/table slots) so references update
    if owners[targetFn] then
        for _, ref in ipairs(owners[targetFn]) do
            if ref.kind == "table" and typeof(ref.owner)=="table" then
                pcall(function() ref.owner[ref.key] = wrapper end)
            elseif ref.kind == "upvalue" and typeof(ref.owner)=="function" then
                pcall(function() debug.setupvalue(ref.owner, ref.key, wrapper) end)
            end
        end
    end

    if okHook then
        print(("[LDI] Hooked %s via hookfunction + patched refs."):format(targetName))
    else
        print(("[LDI] Patched %s via upvalues/tables (hookfunction unavailable or blocked)."):format(targetName))
    end
end

if not targets.doLasso and not targets._hit then
    print("[LDI] Couldn’t locate doLasso/_hit through reachable closures. Try triggering the lasso once, then run this again.")
else
    if targets.doLasso then replaceEverywhere("doLasso", targets.doLasso) else print("[LDI] doLasso not found (yet).") end
    if targets._hit    then replaceEverywhere("_hit",    targets._hit)    else print("[LDI] _hit not found (yet).")    end
    print("[LDI] Ready. Do one real lasso/tame; exact args/returns will print once, then you can reuse _G.LASSO_LASTARGS_doLasso / _hit.")
end
