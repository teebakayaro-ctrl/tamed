-- Lasso Arg Inspector (doLasso + _hit)
-- Minimal, scoped, nil-safe. Prints only when those two functions run.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function pretty(v)
    local t = typeof(v)
    if t == "Instance" then
        local okN, nm = pcall(function() return v.Name end)
        local okF, fm = pcall(function() return v:GetFullName() end)
        return string.format("<%s:%s%s>", v.ClassName, okN and nm or "?", okF and (" @"..fm) or "")
    elseif t == "Vector3" or t == "CFrame" or t == "Vector2" or t == "UDim2" or t == "Color3" then
        return tostring(v)
    else
        local ok, s = pcall(function() return tostring(v) end)
        return ok and s or ("<"..t..">")
    end
end

local function packArgs(...)
    local p = table.pack(...)
    local parts = {}
    for i = 1, p.n do parts[i] = string.format("[%d] %s", i, pretty(p[i])) end
    return p, table.concat(parts, "  ")
end

local function findLassoModule()
    local root = ReplicatedStorage:FindFirstChild("_replicationFolder", true)
    if not root then return nil, "No _replicationFolder" end
    local m = root:FindFirstChild("Lasso", true)
    if not m then return nil, "No Lasso ModuleScript" end
    if not m:IsA("ModuleScript") then return nil, "Lasso is not ModuleScript" end
    return m
end

local lassoMS, why = findLassoModule()
if not lassoMS then
    return warn("[Lasso-Inspector] "..why)
end

local okReq, Lasso = pcall(require, lassoMS)
if not okReq then
    return warn("[Lasso-Inspector] require() failed: "..tostring(Lasso))
end

if type(Lasso) ~= "table" then
    return warn("[Lasso-Inspector] require() did not return a table")
end

if Lasso.__inspector_wrapped then
    print("[Lasso-Inspector] Already wrapped.")
    return
end

-- Wrap doLasso
local orig_do = rawget(Lasso, "doLasso")
if type(orig_do) ~= "function" then
    warn("[Lasso-Inspector] Lasso.doLasso not found (function). Did the game obfuscate/rename it?")
else
    local nparams, isvar = debug.info(orig_do, "a")
    print(string.format("[Lasso-Inspector] Found doLasso  params=%s  vararg=%s", tostring(nparams), tostring(isvar)))

    Lasso.doLasso = function(...)
        local args, preview = packArgs(...)
        _G.LASSO_LASTARGS_doLasso = args
        print("[doLasso] args ->  "..preview)
        local r = table.pack(orig_do(...))
        _G.LASSO_LASTRET_doLasso = r
        if r.n > 0 then
            local parts = {}
            for i=1, r.n do parts[i] = string.format("[%d] %s", i, pretty(r[i])) end
            print("[doLasso] returns ->  "..table.concat(parts, "  "))
        end
        return table.unpack(r, 1, r.n)
    end

    -- Try to locate and wrap private _hit via doLasso upvalues
    local wrappedHit = false
    local i = 1
    while true do
        local name, val = debug.getupvalue(orig_do, i)
        if not name then break end
        if type(val) == "function" then
            -- match by upvalue name OR by function debug name
            local fname = debug.info(val, "n") or ""
            if name == "_hit" or (type(fname)=="string" and fname:find("_hit", 1, true)) then
                local orig_hit = val
                local hp, hvar = debug.info(orig_hit, "a")
                print(string.format("[Lasso-Inspector] Found _hit via upvalue #%d  params=%s  vararg=%s", i, tostring(hp), tostring(hvar)))
                local wrapper = function(...)
                    local a, prev = packArgs(...)
                    _G.LASSO_LASTARGS__hit = a
                    print("[_hit] args ->  "..prev)
                    local rr = table.pack(orig_hit(...))
                    _G.LASSO_LASTRET__hit = rr
                    if rr.n > 0 then
                        local parts = {}
                        for k=1, rr.n do parts[k] = string.format("[%d] %s", k, pretty(rr[k])) end
                        print("[_hit] returns ->  "..table.concat(parts, "  "))
                    end
                    return table.unpack(rr, 1, rr.n)
                end
                debug.setupvalue(orig_do, i, wrapper)
                wrappedHit = true
                break
            end
        end
        i += 1
    end
    if not wrappedHit then
        warn("[Lasso-Inspector] Could not locate _hit upvalue from doLasso. It might not be referenced directly.")
    end
end

Lasso.__inspector_wrapped = true
print("[Lasso-Inspector] Ready. Perform one real lasso/tame; youâ€™ll see clean arg prints for doLasso and _hit.")
print("[Lasso-Inspector] Last-captured args are in _G.LASSO_LASTARGS_doLasso and _G.LASSO_LASTARGS__hit.")
